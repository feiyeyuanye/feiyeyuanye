<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

<link rel="preconnect" href="//fonts.loli.net" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic%7CJetBrains+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"jianghouren.cn","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#0593D3","save":"manual"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="article">
<meta property="og:title" content="OkHttp 源码">
<meta property="og:url" content="https://jianghouren.cn/archives/2efded73.html">
<meta property="og:site_name" content="非也缘也 Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imgsw.cn/static/images/虚构推理.png">
<meta property="article:published_time" content="2020-01-01T14:03:38.000Z">
<meta property="article:modified_time" content="2020-07-05T02:52:29.000Z">
<meta property="article:author" content="非也缘也">
<meta property="article:tag" content="库与框架">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgsw.cn/static/images/虚构推理.png">


<link rel="canonical" href="https://jianghouren.cn/archives/2efded73.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jianghouren.cn/archives/2efded73.html","path":"archives/2efded73.html","title":"OkHttp 源码"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>OkHttp 源码 | 非也缘也 Blog</title>
  




<link rel="dns-prefetch" href="https://waline-git-main-feiyeyuanyes-projects.vercel.app/">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">非也缘也 Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Hello World</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#OkHttpClient"><span class="nav-number">1.</span> <span class="nav-text">OkHttpClient</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E7%BD%91%E7%BB%9C"><span class="nav-number">2.</span> <span class="nav-text">请求网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="nav-number">2.1.</span> <span class="nav-text">异步请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dispatcher-%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">Dispatcher 调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncCall-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.</span> <span class="nav-text">AsyncCall 的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interceptor-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-number">2.4.</span> <span class="nav-text">Interceptor 拦截器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RetryAndFollowUpInterceptor"><span class="nav-number">2.4.1.</span> <span class="nav-text">RetryAndFollowUpInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BridgeInterceptor"><span class="nav-number">2.4.2.</span> <span class="nav-text">BridgeInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CacheInterceptor"><span class="nav-number">2.4.3.</span> <span class="nav-text">CacheInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConnectInterceptor"><span class="nav-number">2.4.4.</span> <span class="nav-text">ConnectInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CallServerInterceptor"><span class="nav-number">2.4.5.</span> <span class="nav-text">CallServerInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F-OkHttp-%E8%B4%A3%E4%BB%BB%E9%93%BE"><span class="nav-number">2.4.6.</span> <span class="nav-text">模拟 OkHttp 责任链</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="nav-number">2.5.</span> <span class="nav-text">同步请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.6.</span> <span class="nav-text">简述请求执行流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">3.</span> <span class="nav-text">复用连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.</span> <span class="nav-text">缓存操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%9B%9E%E6%94%B6%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.2.</span> <span class="nav-text">自动回收连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">引用计数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF"><span class="nav-number">4.</span> <span class="nav-text">优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5"><span class="nav-number">5.</span> <span class="nav-text">链接</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="非也缘也"
      src="https://imgsw.cn/static/images/blog_portrait.jpeg">
  <p class="site-author-name" itemprop="name">非也缘也</p>
  <div class="site-description" itemprop="description">不可描述</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">202</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/feiyeyuanye" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;feiyeyuanye" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/10814718/feiyeyuanye" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;10814718&#x2F;feiyeyuanye" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/wu-wang-chu-xin-28/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;wu-wang-chu-xin-28&#x2F;" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-audible fa-fw"></i>LeetCode</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://developer.android.google.cn/" title="https:&#x2F;&#x2F;developer.android.google.cn&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">· Developers</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://wanandroid.com/" title="https:&#x2F;&#x2F;wanandroid.com&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">· WanAndroid</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://liuwangshu.cn/" title="https:&#x2F;&#x2F;liuwangshu.cn&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">· 刘望舒</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jianghouren.cn/archives/2efded73.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://imgsw.cn/static/images/blog_portrait.jpeg">
      <meta itemprop="name" content="非也缘也">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="非也缘也 Blog">
      <meta itemprop="description" content="不可描述">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="OkHttp 源码 | 非也缘也 Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OkHttp 源码
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-01 22:03:38" itemprop="dateCreated datePublished" datetime="2020-01-01T22:03:38+08:00">2020-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-07-05 10:52:29" itemprop="dateModified" datetime="2020-07-05T10:52:29+08:00">2020-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android-%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">Android 知识点</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/archives/2efded73.html#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/archives/2efded73.html" data-xid="/archives/2efded73.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/archives/2efded73.html" class="post-meta-item leancloud_visitors" data-flag-title="OkHttp 源码" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  



    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>36k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>33 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <img data-src="https://imgsw.cn/static/images/虚构推理.png" class="m_more_content_bg_img" />

<span id="more"></span>

<h2 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a><p class="m_more_title_style">OkHttpClient</p></h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">okHttpClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其内部实现了 Builder()</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OkHttpClient</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">Builder</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现了一些默认的配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">      dispatcher = <span class="keyword">new</span> <span class="title class_">Dispatcher</span>();</span><br><span class="line">      protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">      connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">      eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">      proxySelector = ProxySelector.getDefault();</span><br><span class="line">      <span class="keyword">if</span> (proxySelector == <span class="literal">null</span>) &#123;</span><br><span class="line">        proxySelector = <span class="keyword">new</span> <span class="title class_">NullProxySelector</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">      socketFactory = SocketFactory.getDefault();</span><br><span class="line">      hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">      certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">      proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">      authenticator = Authenticator.NONE;</span><br><span class="line">      <span class="comment">// 初始化连接池</span></span><br><span class="line">      connectionPool = <span class="keyword">new</span> <span class="title class_">ConnectionPool</span>();</span><br><span class="line">      dns = Dns.SYSTEM;</span><br><span class="line">      followSslRedirects = <span class="literal">true</span>;</span><br><span class="line">      followRedirects = <span class="literal">true</span>;</span><br><span class="line">      retryOnConnectionFailure = <span class="literal">true</span>;</span><br><span class="line">      callTimeout = <span class="number">0</span>;</span><br><span class="line">      connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">      readTimeout = <span class="number">10_000</span>;</span><br><span class="line">      writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">      pingInterval = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Dispatcher dispatcher;  <span class="comment">// 调度器</span></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span> Proxy proxy;  <span class="comment">// 代理</span></span><br><span class="line"><span class="keyword">final</span> List&lt;Protocol&gt; protocols;  <span class="comment">// 协议</span></span><br><span class="line"><span class="keyword">final</span> List&lt;ConnectionSpec&gt; connectionSpecs;  <span class="comment">// 传输层版本和连接协议</span></span><br><span class="line"><span class="keyword">final</span> List&lt;Interceptor&gt; interceptors;  <span class="comment">// 拦截器</span></span><br><span class="line"><span class="keyword">final</span> List&lt;Interceptor&gt; networkInterceptors;  <span class="comment">// 网络拦截器</span></span><br><span class="line"><span class="keyword">final</span> EventListener.Factory eventListenerFactory;   </span><br><span class="line"><span class="keyword">final</span> ProxySelector proxySelector;  <span class="comment">// 代理选择器</span></span><br><span class="line"><span class="keyword">final</span> CookieJar cookieJar;  <span class="comment">// cookie</span></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span> Cache cache;  <span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span> InternalCache internalCache;  <span class="comment">// 内部缓存</span></span><br><span class="line"><span class="keyword">final</span> SocketFactory socketFactory;  <span class="comment">// socket 工厂</span></span><br><span class="line"><span class="keyword">final</span> SSLSocketFactory sslSocketFactory;  <span class="comment">// 安全套层 socket 工厂，用于 https</span></span><br><span class="line"><span class="keyword">final</span> CertificateChainCleaner certificateChainCleaner;<span class="comment">//验证确认响应书，适用https请求连接的主机名</span></span><br><span class="line"><span class="keyword">final</span> HostnameVerifier hostnameVerifier;  <span class="comment">// 主机名字确认</span></span><br><span class="line"><span class="keyword">final</span> CertificatePinner certificatePinner;  <span class="comment">// 证书链</span></span><br><span class="line"><span class="keyword">final</span> Authenticator proxyAuthenticator;  <span class="comment">// 代理身份验证</span></span><br><span class="line"><span class="keyword">final</span> Authenticator authenticator;  <span class="comment">// 本地身份验证</span></span><br><span class="line"><span class="keyword">final</span> ConnectionPool connectionPool;  <span class="comment">// 链接池，复用链接</span></span><br><span class="line"><span class="keyword">final</span> Dns dns;  <span class="comment">// 域名</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> followSslRedirects;  <span class="comment">// 安全套接层重定向</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> followRedirects;  <span class="comment">// 本地重定向</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> retryOnConnectionFailure;  <span class="comment">// 重试连接失败</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> callTimeout;  <span class="comment">// </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> connectTimeout;  <span class="comment">// 连接超时</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> readTimeout;  <span class="comment">// 读取超时</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> writeTimeout;  <span class="comment">// 写入超时</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> pingInterval;  <span class="comment">// </span></span><br></pre></td></tr></table></figure>

<h2 id="请求网络"><a href="#请求网络" class="headerlink" title="请求网络"></a><p class="m_more_title_style">请求网络</p></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论是同步请求还是异步请求，都是由 Call 来调用。</span></span><br><span class="line"><span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> okHttpClient.newCall(request);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正的请求实现由 RealCall 完成</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> RealCall.newRealCall(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RealCall 类内部</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span> &#123;</span><br><span class="line">  <span class="comment">// 确保每个 Call 只能被执行一次，不能重复执行。</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此行代码有版本差异</span></span><br><span class="line">  transmitter.callStart();</span><br><span class="line">  <span class="comment">// 利用 dispatcher 调度器，来进行实际的执行。</span></span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> <span class="title class_">AsyncCall</span>(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dispatcher-调度器"><a href="#Dispatcher-调度器" class="headerlink" title="Dispatcher 调度器"></a>Dispatcher 调度器</h3><p>Dispatcher 主要用于控制并发的请求</p>
<p>它有两个构造方法，可使用自定义的线程池，或默认线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Dispatcher</span><span class="params">(ExecutorService executorService)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.executorService = executorService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Dispatcher</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title function_">executorService</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (executorService == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 类似于 CachedThreadPool，比较适合执行大量的耗时比较少的任务。</span></span><br><span class="line">    executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequests</span> <span class="operator">=</span> <span class="number">64</span>;  <span class="comment">// 最大并发请求数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequestsPerHost</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 同时请求的相同 HOST 的最大个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> Runnable idleCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Executes calls. Created lazily. */</span></span><br><span class="line"><span class="comment">// 消费者线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ready async calls in the order they&#x27;ll be run. */</span></span><br><span class="line"><span class="comment">// 异步等待队列。。双端队列，支持首尾两端 双向开口可进可出，方便移除。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line"><span class="comment">//  正在运行的异步请求队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Running synchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line"><span class="comment">// 正在运行的同步请求队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当调用 RealCall 的 enqueue()，实际上是调用了 Dispatcher 的 enqueue()。</span></span><br><span class="line"><span class="comment">// 异步请求</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(AsyncCall call)</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 有版本差异，此前会判断当正在运行的异步请求队列中的数量小于 64 并且正在运行的请求主机数小于 5 时，把请求加载到 runningAsyncCalls 中并在线程池中执行，否则就加入到 readyAsyncCalls 中进行缓存等待。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加入等候队列，AsyncCall 是 RealCall 的内部类，其内部也实现了 execute()。</span></span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okhttp 会使用共享主机，即地址相同的会共享 socket。</span></span><br><span class="line">    <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">      <span class="comment">// findExistingCallWithHost() 通过循环判断相同的 host</span></span><br><span class="line">      <span class="type">AsyncCall</span> <span class="variable">existingCall</span> <span class="operator">=</span> findExistingCallWithHost(call.host());</span><br><span class="line">      <span class="keyword">if</span> (existingCall != <span class="literal">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  promoteAndExecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将符合条件的调用从&#123;<span class="doctag">@link</span> #readyAsyncCalls&#125;提升到&#123;<span class="doctag">@link</span> #runningAsyncCalls&#125;，并在executor服务上运* 行它们。不能同步调用，因为执行的调用可以调用用户代码。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果调度程序当前正在运行调用，则为true。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">promoteAndExecute</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">assert</span> (!Thread.holdsLock(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">  List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="type">boolean</span> isRunning;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 从 readyAsyncCalls 取出下一个请求，加入 runningAsyncCalls 并交由线程池处理。</span></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      <span class="type">AsyncCall</span> <span class="variable">asyncCall</span> <span class="operator">=</span> i.next();</span><br><span class="line">      <span class="comment">// 同时请求不能超过并发数(64,可配置调度器调整).</span></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="comment">// 最大的 DNS 解析，默认值 5。同一个 host 最多允许 5 条线程通知执行请求。</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">      i.remove();</span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">      executableCalls.add(asyncCall);</span><br><span class="line">      <span class="comment">// 加入运行队列，并交给线程池执行。</span></span><br><span class="line">      runningAsyncCalls.add(asyncCall);</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">    <span class="type">AsyncCall</span> <span class="variable">asyncCall</span> <span class="operator">=</span> executableCalls.get(i);</span><br><span class="line">    asyncCall.executeOn(executorService());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">executeOn</span><span class="params">(ExecutorService executorService)</span> &#123;</span><br><span class="line">      <span class="keyword">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// AsyncCall 是一个 runnable，放到线程池中去执行。</span></span><br><span class="line">        executorService.execute(<span class="built_in">this</span>);</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        <span class="type">InterruptedIOException</span> <span class="variable">ioException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterruptedIOException</span>(<span class="string">&quot;executor rejected&quot;</span>);</span><br><span class="line">        ioException.initCause(e);</span><br><span class="line">        transmitter.noMoreExchanges(ioException);</span><br><span class="line">        responseCallback.onFailure(RealCall.<span class="built_in">this</span>, ioException);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          client.dispatcher().finished(<span class="built_in">this</span>); <span class="comment">// This call is no longer running!</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AsyncCall-的实现"><a href="#AsyncCall-的实现" class="headerlink" title="AsyncCall 的实现"></a>AsyncCall 的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AsyncCall</span> <span class="keyword">extends</span> <span class="title class_">NamedRunnable</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NamedRunnable 是一个 Runnable ，所以 AsyncCall 是一个 Runnable。</span></span><br><span class="line"><span class="comment">// 线程池实际上是执行了 execute()。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">NamedRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">NamedRunnable</span><span class="params">(String format, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = Util.format(format, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">oldName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    Thread.currentThread().setName(name);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      execute();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Thread.currentThread().setName(oldName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">signalledCallback</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  transmitter.timeoutEnter();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 责任链模式</span></span><br><span class="line">    <span class="comment">// 拦截器链  真正执行请求网络</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> getResponseWithInterceptorChain();</span><br><span class="line">    signalledCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 回调结果，将 response 返回给用户</span></span><br><span class="line">    responseCallback.onResponse(RealCall.<span class="built_in">this</span>, response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">      <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">      Platform.get().log(INFO, <span class="string">&quot;Callback failure for &quot;</span> + toLoggableString(), e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      responseCallback.onFailure(RealCall.<span class="built_in">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论请求结果如何，通过调度器移除队列</span></span><br><span class="line">    client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> &#123;</span><br><span class="line">  Runnable idleCallback;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 移除队列，将此次请求从 runningAsyncCalls 移除。</span></span><br><span class="line">    <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>);</span><br><span class="line">    idleCallback = <span class="built_in">this</span>.idleCallback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里不再是调用 promoteCalls()，而是调用了 promoteAndExecute()。</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> promoteAndExecute();</span><br><span class="line">  <span class="comment">// 闲置调用</span></span><br><span class="line">  <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">    idleCallback.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Interceptor-拦截器"><a href="#Interceptor-拦截器" class="headerlink" title="Interceptor 拦截器"></a>Interceptor 拦截器</h3><p>拦截器是一种能够监控，重写，重试调用的机制。通常情况下，拦截器用来添加，移除，转换请求和响应的头部信息。比如将域名替换为 IP 地址，在请求头中添加 host 属性，也可以添加应用中的一些公共参数，比如设备 id，版本号等等。</p>
<p>通过拦截链的设计，让请求分成5个拦截器去处理，拦截器各司其职，扩展性非常高。拦截链是从自定义的拦截器开始，然后再到默认的5个拦截器。一般情况下想打印网络请求日志，可以自定义Log拦截器，如果要给所有请求添加Header，同样可以自定义Header拦截器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* RealCall 的 getResponseWithInterceptorChain()</span></span><br><span class="line"><span class="comment">*  真正执行网络请求和返回响应结果</span></span><br><span class="line"><span class="comment">* 实现了Interceptor接口，采用责任链的模式来使每个功能分开，每个Interceptor自行完成自己的任务，并且将不属于* 自己的任务交给下一个，简化了各自的责任和逻辑。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 执行流程：</span></span><br><span class="line"><span class="comment">* 自定义的 interceptor</span></span><br><span class="line"><span class="comment">* RetryAndFollowUpInterceptor 失败重试、重定向拦截器。</span></span><br><span class="line"><span class="comment">* BridgeInterceptor(client.cookieJar()) 桥拦截器：主要是添加和删除一些header</span></span><br><span class="line"><span class="comment">* CacheInterceptor(client.internalCache()) 缓存拦截器：根据缓存策略，如果缓存可用，直接返回缓存数据。</span></span><br><span class="line"><span class="comment">* ConnectInterceptor(client) 连接池拦截器：连接池会缓存http链接，连接池的好处是复用连接，少了3次握手，所* 以请求会更快</span></span><br><span class="line"><span class="comment">* client.networkInterceptors() --如果有设置的话</span></span><br><span class="line"><span class="comment">* CallServerInterceptor(forWebSocket) 真正访问网络的拦截器：内部使用okio去发请求</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  <span class="comment">// 责任链</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 在配置 okhttpClient 时设置的intercept 由用户自己设置</span></span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  <span class="comment">// 负责处理失败后的重试与重定向</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">RetryAndFollowUpInterceptor</span>(client));</span><br><span class="line">  <span class="comment">// 桥拦截器，从应用程序代码到网络代码的桥梁。负责把用户构造的请求转换为发送到服务器的请求，把服务器返回的响应转换为用户友好的响应，处理、配置请求头等信息。</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">  <span class="comment">// 处理 缓存配置 根据条件(存在响应缓存并被设置为不变的或者响应在有效期内)返回缓存响应</span></span><br><span class="line">  <span class="comment">// 设置请求头(If-None-Match、If-Modified-Since等) 服务器可能返回304(未修改)</span></span><br><span class="line">  <span class="comment">// 可配置用户自己设置的缓存拦截器</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));</span><br><span class="line">  <span class="comment">// 连接服务器 负责和服务器建立连接 这里才是真正的请求网络</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    <span class="comment">// 配置 okhttpClient 时设置的 networkInterceptors</span></span><br><span class="line">    <span class="comment">// 返回观察单个网络请求和响应的不可变拦截器列表。</span></span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行流操作(写出请求体、获得响应数据) 负责向服务器发送请求数据、从服务器读取响应数据</span></span><br><span class="line">  <span class="comment">// 进行http请求报文的封装与请求报文的解析</span></span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket));</span><br><span class="line">  <span class="comment">// 创建责任链</span></span><br><span class="line">  Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, transmitter, <span class="literal">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="built_in">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">calledNoMoreExchanges</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行责任链，使用责任链模式开启链式调用。</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> chain.proceed(originalRequest);</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">      closeQuietly(response);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* RealInterceptorChain 实现了 Interceptor.Chain 接口，是一个负责管理拦截链的类，每个拦截器调用       * chain.proceed(request)，就会走到下一个拦截器的 intercept方法。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 拦截链最底部的拦截器是 CallServerInterceptor，用 okio 请求网络返回了 Response，然后 Response 往这个* 拦截链回传，上一个拦截器通过 response = chain.proceed(request);就获取到response了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">proceed</span><span class="params">(Request request, Transmitter transmitter, <span class="meta">@Nullable</span> Exchange exchange)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">  <span class="comment">// 创建新的拦截链，链中的拦截器集合index+1。</span></span><br><span class="line">  <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, transmitter, exchange,</span><br><span class="line">      index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">  <span class="comment">// 执行当前的拦截器，如果在配置 okhttpClient 时没有设置 intercept。默认是先执行；RetryAndFollowUpInterceptor 拦截器</span></span><br><span class="line">  <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);</span><br><span class="line">  <span class="comment">// 顺序执行拦截器</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h4><p>失败重试和重定向拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        response = realChain.proceed(request, streamAllocation, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// followUpRequest 判断响应中是否有失败或者重定向（Location）标志，失败的话返回response.request，重定向的话构造新的Request返回</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">followUp</span> <span class="operator">=</span> followUpRequest(response, streamAllocation.route());</span><br><span class="line">        <span class="keyword">if</span> (followUp == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没有失败或重定向，返回response</span></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 用新重定向的request继续while走拦截链</span></span><br><span class="line">        request = followUp;</span><br><span class="line">        priorResponse = response;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h4><p>桥拦截器，添加或者移除一些 header</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">MediaType</span> <span class="variable">contentType</span> <span class="operator">=</span> body.contentType();</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// contentType 不空就加Content-Type这个header</span></span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Content-Type&quot;</span>, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">long</span> <span class="variable">contentLength</span> <span class="operator">=</span> body.contentLength();</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//contentLength 不是-1就加Content-Length这个header</span></span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Content-Length&quot;</span>, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">&quot;Transfer-Encoding&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//移除Content-Length 这个header</span></span><br><span class="line">        requestBuilder.header(<span class="string">&quot;Transfer-Encoding&quot;</span>, <span class="string">&quot;chunked&quot;</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//后面还有响应的header</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h4><p>缓存拦截器：根据缓存策略，判断是否返回缓存数据，响应的数据是否要缓存起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 上半部，没有网络时的处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 如果用户自己配置了缓存拦截器，cacheCandidate = cache.Response 获取用户自己存储的Response,否则 cacheCandidate = null;同时从CacheStrategy 获取cacheResponse 和 networkRequest</span></span><br><span class="line">  <span class="comment">// cacheCandidate 是上次与服务器交互时缓存的 Response，可以读取缓存 Header 的 Respone。这里的缓存均基于 Map。Key 是请求中 url 的 md5，value 是文件中查询到的缓存，页面置换基于 LRU 算法</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">cacheCandidate</span> <span class="operator">=</span> cache != <span class="literal">null</span></span><br><span class="line">      ? cache.get(chain.request())</span><br><span class="line">      : <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// 执行响应缓存策略</span></span><br><span class="line">  <span class="type">CacheStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheStrategy</span>.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">  <span class="comment">// 网络请求，如果networkRequest == null 则说明不使用网络请求</span></span><br><span class="line">  <span class="type">Request</span> <span class="variable">networkRequest</span> <span class="operator">=</span> strategy.networkRequest;</span><br><span class="line">  <span class="comment">// 缓存的响应，获取缓存中（CacheStrategy）的Response</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">cacheResponse</span> <span class="operator">=</span> strategy.cacheResponse;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 记录当前请求是网络发起还是缓存发起</span></span><br><span class="line">    cache.trackResponse(strategy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果cacheCandidate ！= null 而 cacheResponse == null 说明缓存无效，清除cacheCandidate缓存。</span></span><br><span class="line">  <span class="keyword">if</span> (cacheCandidate != <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">    closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn&#x27;t applicable. Close it.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we&#x27;re forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">  <span class="comment">// 不进行网络请求并且缓存不存在或过期，则返回 504 错误，责任链此时也就终止，不会在往下继续执行。</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="literal">null</span> &amp;&amp; cacheResponse == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(<span class="number">504</span>)</span><br><span class="line">        .message(<span class="string">&quot;Unsatisfiable Request (only-if-cached)&quot;</span>)</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we don&#x27;t need the network, we&#x27;re done.</span></span><br><span class="line">  <span class="comment">// 不使用网络请求且存在缓存，则直接返回缓存</span></span><br><span class="line">  <span class="keyword">if</span> (networkRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他情况则请求网络</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下半部，有网络时的处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 执行下一个拦截器，也就是请求网络。</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">networkResponse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    networkResponse = chain.proceed(networkRequest);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse == <span class="literal">null</span> &amp;&amp; cacheCandidate != <span class="literal">null</span>) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 责任链执行完毕后，会返回最终响应数据，如果缓存存在更新缓存，如果缓存不存在加入到缓存中去。</span></span><br><span class="line">  <span class="comment">// 责任链的好处，当责任链执行完毕，如果拦截器想要拿到最终的数据做其他的逻辑处理等，这样就不用在做其他的调用方法逻辑了，直接在当前的拦截器就可以拿到最终的数据。</span></span><br><span class="line">  <span class="comment">// If we have a cache response too, then we&#x27;re doing a conditional get.</span></span><br><span class="line">  <span class="comment">// 如果有缓存并可用，则用缓存的数据并更新缓存，否则就用网络请求返回的数据。</span></span><br><span class="line">  <span class="keyword">if</span> (cacheResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 304响应码，则缓存有效，说明自从上次请求后，请求需要响应的内容未发生改变，就用当前缓存的 Response，关闭网络连接，释放连接。</span></span><br><span class="line">    <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build();</span><br><span class="line">      networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">      <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">      cache.trackConditionalCacheHit();</span><br><span class="line">      cache.update(cacheResponse, response);</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 缓存Response</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> networkResponse.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">      <span class="type">CacheRequest</span> <span class="variable">cacheRequest</span> <span class="operator">=</span> cache.put(response);</span><br><span class="line">      <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cache.remove(networkRequest);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">        <span class="comment">// The cache cannot be written.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h4><p>连接池拦截器：主要是从连接池去取连接，http请求要先3次握手才能建立连接，复用连接可以免去握手的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RealInterceptorChain</span> <span class="variable">realChain</span> <span class="operator">=</span> (RealInterceptorChain) chain;</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> realChain.request();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 以前的版本：StreamAllocation streamAllocation = realChain.streamAllocation();</span></span><br><span class="line">    <span class="type">Transmitter</span> <span class="variable">transmitter</span> <span class="operator">=</span> realChain.transmitter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">doExtensiveHealthChecks</span> <span class="operator">=</span> !request.method().equals(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">    <span class="type">Exchange</span> <span class="variable">exchange</span> <span class="operator">=</span> transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns a new exchange to carry a new request and response. */</span></span><br><span class="line">Exchange <span class="title function_">newExchange</span><span class="params">(Interceptor.Chain chain, <span class="type">boolean</span> doExtensiveHealthChecks)</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    <span class="keyword">if</span> (noMoreExchanges) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;released&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;cannot make a new request because the previous response &quot;</span></span><br><span class="line">          + <span class="string">&quot;is still open: please call response.close()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ExchangeCodec</span> <span class="variable">codec</span> <span class="operator">=</span> exchangeFinder.find(client, chain, doExtensiveHealthChecks);</span><br><span class="line">  <span class="type">Exchange</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exchange</span>(<span class="built_in">this</span>, call, eventListener, exchangeFinder, codec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    <span class="built_in">this</span>.exchange = result;</span><br><span class="line">    <span class="built_in">this</span>.exchangeRequestDone = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.exchangeResponseDone = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ExchangeCodec <span class="title function_">find</span><span class="params">(</span></span><br><span class="line"><span class="params">    OkHttpClient client, Interceptor.Chain chain, <span class="type">boolean</span> doExtensiveHealthChecks)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">connectTimeout</span> <span class="operator">=</span> chain.connectTimeoutMillis();</span><br><span class="line">  <span class="type">int</span> <span class="variable">readTimeout</span> <span class="operator">=</span> chain.readTimeoutMillis();</span><br><span class="line">  <span class="type">int</span> <span class="variable">writeTimeout</span> <span class="operator">=</span> chain.writeTimeoutMillis();</span><br><span class="line">  <span class="type">int</span> <span class="variable">pingIntervalMillis</span> <span class="operator">=</span> client.pingIntervalMillis();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">connectionRetryEnabled</span> <span class="operator">=</span> client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 找一个连接</span></span><br><span class="line">    <span class="type">RealConnection</span> <span class="variable">resultConnection</span> <span class="operator">=</span> findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">    <span class="keyword">return</span> resultConnection.newCodec(client, chain);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">    trackFailure();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    trackFailure();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RouteException</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated</span></span><br><span class="line"><span class="comment"> * until a healthy connection is found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 获取连接的方法</span></span><br><span class="line"><span class="keyword">private</span> RealConnection <span class="title function_">findHealthyConnection</span><span class="params">(<span class="type">int</span> connectTimeout, <span class="type">int</span> readTimeout,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> writeTimeout, <span class="type">int</span> pingIntervalMillis, <span class="type">boolean</span> connectionRetryEnabled,</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> doExtensiveHealthChecks)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">RealConnection</span> <span class="variable">candidate</span> <span class="operator">=</span> findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">        pingIntervalMillis, connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></span><br><span class="line">    <span class="comment">// isn&#x27;t, take it out of the pool and start again.</span></span><br><span class="line">    <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">      candidate.noNewExchanges();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h4><p>发送和接收数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class:CallServerInterceptor</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RealInterceptorChain</span> <span class="variable">realChain</span> <span class="operator">=</span> (RealInterceptorChain) chain;</span><br><span class="line">    <span class="type">Exchange</span> <span class="variable">exchange</span> <span class="operator">=</span> realChain.exchange();</span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> realChain.request();</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">sentRequestMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    exchange.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">responseHeadersStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Response.<span class="type">Builder</span> <span class="variable">responseBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If there&#x27;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span></span><br><span class="line">      <span class="comment">// Continue&quot; response before transmitting the request body. If we don&#x27;t get that, return</span></span><br><span class="line">      <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;100-continue&quot;</span>.equalsIgnoreCase(request.header(<span class="string">&quot;Expect&quot;</span>))) &#123;</span><br><span class="line">        exchange.flushRequest();</span><br><span class="line">        responseHeadersStarted = <span class="literal">true</span>;</span><br><span class="line">        exchange.responseHeadersStart();</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.body().isDuplex()) &#123;</span><br><span class="line">          <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">          exchange.flushRequest();</span><br><span class="line">          <span class="type">BufferedSink</span> <span class="variable">bufferedRequestBody</span> <span class="operator">=</span> Okio.buffer(</span><br><span class="line">              exchange.createRequestBody(request, <span class="literal">true</span>));</span><br><span class="line">          request.body().writeTo(bufferedRequestBody);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span></span><br><span class="line">          <span class="type">BufferedSink</span> <span class="variable">bufferedRequestBody</span> <span class="operator">=</span> Okio.buffer(</span><br><span class="line">              exchange.createRequestBody(request, <span class="literal">false</span>));</span><br><span class="line">          request.body().writeTo(bufferedRequestBody);</span><br><span class="line">          bufferedRequestBody.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody();</span><br><span class="line">        <span class="keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;</span><br><span class="line">          <span class="comment">// If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1 connection</span></span><br><span class="line">          <span class="comment">// from being reused. Otherwise we&#x27;re still obligated to transmit the request body to</span></span><br><span class="line">          <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">          exchange.noNewExchangesOnConnection();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.body() == <span class="literal">null</span> || !request.body().isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">      exchange.responseHeadersStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">      responseBuilder = exchange.readResponseHeaders(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> response.code();</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">      <span class="comment">// try again to read the actual response</span></span><br><span class="line">      response = exchange.readResponseHeaders(<span class="literal">false</span>)</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection().handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build();</span><br><span class="line"></span><br><span class="line">      code = response.code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">      <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .body(Util.EMPTY_RESPONSE)</span><br><span class="line">          .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 最终获取 response 方法 exchange.openResponseBody(response)</span></span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.request().header(<span class="string">&quot;Connection&quot;</span>))</span><br><span class="line">        || <span class="string">&quot;close&quot;</span>.equalsIgnoreCase(response.header(<span class="string">&quot;Connection&quot;</span>))) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ProtocolException</span>(</span><br><span class="line">          <span class="string">&quot;HTTP &quot;</span> + code + <span class="string">&quot; had non-zero Content-Length: &quot;</span> + response.body().contentLength());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拦截链已经到底部，直接返回 response，将response回传给上一个拦截器</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class：Exchange</span></span><br><span class="line"><span class="keyword">public</span> ResponseBody <span class="title function_">openResponseBody</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//内部就是通过Okio.buffer去请求网络</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RealResponseBody</span>(contentType, contentLength, Okio.buffer(source));</span><br><span class="line">    </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模拟-OkHttp-责任链"><a href="#模拟-OkHttp-责任链" class="headerlink" title="模拟 OkHttp 责任链"></a>模拟 OkHttp 责任链</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line">        String <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">        String <span class="title function_">proceed</span><span class="params">(String request)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 BridgeInterceptor 拦截器之前代码&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">proceed</span> <span class="operator">=</span> chain.proceed(chain.request());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 BridgeInterceptor 拦截器之后代码 得到最终数据：&quot;</span>+proceed);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryAndFollowInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 RetryAndFollowInterceptor 拦截器之前代码&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">proceed</span> <span class="operator">=</span> chain.proceed(chain.request());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 RetryAndFollowInterceptor 拦截器之后代码 得到最终数据：&quot;</span> + proceed);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">interceptor</span><span class="params">(Chain chain)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 CacheInterceptor 最后一个拦截器 返回最终数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span>.Chain &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Interceptor&gt; interceptors;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> String request;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RealInterceptorChain</span><span class="params">(List&lt;Interceptor&gt; interceptors,<span class="type">int</span> index,String request)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.interceptors = interceptors;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">proceed</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= interceptors.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 获取下一个责任链</span></span><br><span class="line">        <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors,index+<span class="number">1</span>,request);</span><br><span class="line">        <span class="comment">// 执行当前的拦截器</span></span><br><span class="line">        <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> interceptor.interceptor(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>());</span><br><span class="line">interceptors.add(<span class="keyword">new</span> <span class="title class_">RetryAndFollowInterceptor</span>());</span><br><span class="line">interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>());</span><br><span class="line"><span class="type">RealInterceptorChain</span> <span class="variable">realInterceptorChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors,<span class="number">0</span>,<span class="string">&quot;request&quot;</span>);</span><br><span class="line">realInterceptorChain.proceed(<span class="string">&quot;request&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// 执行 BridgeInterceptor 拦截器之前代码</span></span><br><span class="line"><span class="comment">// 执行 RetryAndFollowInterceptor 拦截器之前代码</span></span><br><span class="line"><span class="comment">// 执行 CacheInterceptor 最后一个拦截器 返回最终数据</span></span><br><span class="line"><span class="comment">// 执行 RetryAndFollowInterceptor 拦截器之后代码 得到最终数据：success</span></span><br><span class="line"><span class="comment">// 执行 BridgeInterceptor 拦截器之后代码 得到最终数据：success</span></span><br></pre></td></tr></table></figure>

<h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步请求，直接返回一个请求的结果。</span></span><br><span class="line"><span class="comment">// 在同步请求的方法中，涉及到dispatcher 只是告知了执行状态，开始执行了（调用 executed），执行完毕了（调用 finished）其他的并没有涉及到。dispatcher 更多的是服务异步请求。</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 避免重复执行</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.timeoutEnter();</span><br><span class="line">  transmitter.callStart();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 交给调度器去执行，实际上调度器只是将 call 加入到了同步执行队列中。</span></span><br><span class="line">    <span class="comment">// 将 RealCall 加到队列 Deque&lt;RealCall&gt; runningSyncCalls</span></span><br><span class="line">    client.dispatcher().executed(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 通过一系列的拦截器请求处理和响应处理得到最终的返回结果</span></span><br><span class="line">    <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 执行调度器的完成方法，移除队列</span></span><br><span class="line">    client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简述请求执行流程"><a href="#简述请求执行流程" class="headerlink" title="简述请求执行流程"></a>简述请求执行流程</h3><p>1、OkhttpClient 实现了 Call.Fctory，负责为 Request 创建 Call；</p>
<p>2、RealCall 为 Call 的具体实现，其 enqueue() 异步请求接口通过 Dispatcher() 调度器利用 ExcutorService 实现，而最终进行网络请求时和同步的 execute() 接口一致，都是通过 getResponseWithInterceptorChain() 函数实现。</p>
<p>3、getResponseWithInterceptorChain() 中利用 Interceptor 链条，责任链模式 分层实现缓存、透明压缩、网络 IO 等功能，最终将响应数据返回给用户。</p>
<h2 id="复用连接池"><a href="#复用连接池" class="headerlink" title="复用连接池"></a><p class="m_more_title_style">复用连接池</p></h2><p>连接池位于 okhttp3.ConnectionPool：</p>
<p>连接池复用的核心就是用 Deque<RealConnection> 来存储连接，通过 put 等操作来对 Deque 进行操作，另外通过判断连接中的计数对象 Transmitter 来进行自动回收连接。</p>
<p>okhttp3.ConnectionPool 在 OkHttpClient 实例化时创建，它的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认空闲的 socket 最大连接数为 5 个，socket 的 keepAlive 时间为 5 分钟。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConnectionPool</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConnectionPool</span><span class="params">(<span class="type">int</span> maxIdleConnections, <span class="type">long</span> keepAliveDuration, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.delegate = <span class="keyword">new</span> <span class="title class_">RealConnectionPool</span>(maxIdleConnections, keepAliveDuration, timeUnit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的主要变量位于 okhttp3.internal.connection.RealConnectionPool：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Background threads are used to cleanup expired connections. There will be at most a single</span></span><br><span class="line"><span class="comment"> * thread running per connection pool. The thread pool executor permits the pool itself to be</span></span><br><span class="line"><span class="comment"> * garbage collected.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 线程池，类似于 CachedThreadPool，工作队列采用了没有容量的 SynchronousQueue。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</span><br><span class="line">    Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp ConnectionPool&quot;</span>, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The maximum number of idle connections for each address. */</span></span><br><span class="line"><span class="comment">// 空闲的 socket 最大连接数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxIdleConnections;</span><br><span class="line"><span class="comment">// socket 的 keepAlive 时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> keepAliveDurationNs;</span><br><span class="line"><span class="comment">// 双向队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，里面维护了 RealConnection 也就是 socket物理连接的包装。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 用来记录连接失败的路线名单，当连接失败的时候就会把失败的线路加进去。</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">RouteDatabase</span> <span class="variable">routeDatabase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RouteDatabase</span>();</span><br><span class="line"><span class="type">boolean</span> cleanupRunning;</span><br></pre></td></tr></table></figure>

<h3 id="缓存操作"><a href="#缓存操作" class="headerlink" title="缓存操作"></a>缓存操作</h3><p>RealConnectionPool 提供了对 Deque<RealConnection> 的一些操作，比如放入连接，获取连接，移除连接，移除所有连接。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to acquire a recycled connection to &#123;<span class="doctag">@code</span> address&#125; for &#123;<span class="doctag">@code</span> transmitter&#125;. Returns</span></span><br><span class="line"><span class="comment"> * true if a connection was acquired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If &#123;<span class="doctag">@code</span> routes&#125; is non-null these are the resolved routes (ie. IP addresses) for the</span></span><br><span class="line"><span class="comment"> * connection. This is used to coalesce related domains to the same HTTP/2 connection, such as</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> square.com&#125; and &#123;<span class="doctag">@code</span> square.ca&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 替换了以前版本的 get()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">transmitterAcquirePooledConnection</span><span class="params">(Address address, Transmitter transmitter,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> List&lt;Route&gt; routes, <span class="type">boolean</span> requireMultiplexed)</span> &#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="built_in">this</span>));</span><br><span class="line">  <span class="comment">// 遍历 connections 缓存列表。</span></span><br><span class="line">  <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (requireMultiplexed &amp;&amp; !connection.isMultiplexed()) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!connection.isEligible(address, routes)) <span class="keyword">continue</span>;</span><br><span class="line">    transmitter.acquireConnectionNoEvents(connection);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加到 Deque 之前首先要清理空闲的线程</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(RealConnection connection)</span> &#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="built_in">this</span>));</span><br><span class="line">  <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">    cleanupRunning = <span class="literal">true</span>;</span><br><span class="line">    executor.execute(cleanupRunnable);</span><br><span class="line">  &#125;</span><br><span class="line">  connections.add(connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Notify this pool that &#123;<span class="doctag">@code</span> connection&#125; has become idle. Returns true if the connection has</span></span><br><span class="line"><span class="comment"> * been removed from the pool and should be closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">connectionBecameIdle</span><span class="params">(RealConnection connection)</span> &#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="built_in">this</span>));</span><br><span class="line">  <span class="keyword">if</span> (connection.noNewExchanges || maxIdleConnections == <span class="number">0</span>) &#123;</span><br><span class="line">    connections.remove(connection);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    notifyAll(); <span class="comment">// Awake the cleanup thread: we may have exceeded the idle connection limit.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evictAll</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;RealConnection&gt; evictedConnections = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      <span class="type">RealConnection</span> <span class="variable">connection</span> <span class="operator">=</span> i.next();</span><br><span class="line">      <span class="keyword">if</span> (connection.transmitters.isEmpty()) &#123;</span><br><span class="line">        connection.noNewExchanges = <span class="literal">true</span>;</span><br><span class="line">        evictedConnections.add(connection);</span><br><span class="line">        i.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (RealConnection connection : evictedConnections) &#123;</span><br><span class="line">    closeQuietly(connection.socket());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动回收连接"><a href="#自动回收连接" class="headerlink" title="自动回收连接"></a>自动回收连接</h3><p>以前版本是根据 StreamAllocation 引用计数是否为 0 来实现自动回收连接,而现在是通过 Transmitter 类完成.</p>
<p>RealConnection 是 socket 物理连接的包装，里面维护了 List&lt;Reference<Transmitter>&gt;  的引用。List 中 Transmitter 的数量也就是 socket 被引用的计数。如果计数为 0，则说明此连接没有被使用，也就是空闲的，需要通过算法实现回收：如果计数不为 0，则表示上层代码仍然在引用，就无需关闭连接。</p>
<p>在 put 操作时，会调用  executor.execute(cleanupRunnable); 来清理闲置的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">cleanupRunnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 线程不断地调用 cleanup() 进行清理，并返回下次需要清理的间隔时间，然后调用 wait() 进行等待以释放锁与时间片。</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">waitNanos</span> <span class="operator">=</span> cleanup(System.nanoTime());</span><br><span class="line">    <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">waitMillis</span> <span class="operator">=</span> waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">      waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">      <span class="keyword">synchronized</span> (RealConnectionPool.<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          RealConnectionPool.<span class="built_in">this</span>.wait(waitMillis, (<span class="type">int</span>) waitNanos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs maintenance on this pool, evicting the connection that has been idle the longest if</span></span><br><span class="line"><span class="comment"> * either it has exceeded the keep alive limit or the idle connections limit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Returns the duration in nanos to sleep until the next scheduled call to this method. Returns</span></span><br><span class="line"><span class="comment"> * -1 if no further cleanups are required.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 根据连接中的引用计数来计算空闲连接数和活跃连接数，然后标记出空闲的连接。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">cleanup</span><span class="params">(<span class="type">long</span> now)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">inUseConnectionCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">idleConnectionCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">RealConnection</span> <span class="variable">longestIdleConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="type">long</span> <span class="variable">longestIdleDurationNs</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      <span class="type">RealConnection</span> <span class="variable">connection</span> <span class="operator">=</span> i.next();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the connection is in use, keep searching.</span></span><br><span class="line">      <span class="comment">// 判断连接是否闲置。</span></span><br><span class="line">      <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果返回值大于 0 则是活跃连接，否则就是空闲连接。</span></span><br><span class="line">        inUseConnectionCount++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      idleConnectionCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the connection is ready to be evicted, we&#x27;re done.</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">idleDurationNs</span> <span class="operator">=</span> now - connection.idleAtNanos;</span><br><span class="line">      <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">        longestIdleDurationNs = idleDurationNs;</span><br><span class="line">        longestIdleConnection = connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果空闲连接 keepAlive 时间超过 5 分钟，或者空闲连接数超过 5 个，则从 Deque 中移除此连接。接下来根据空闲连接或者活跃连接来返回下次需要清理的时间数：如果空闲连接大于 0 ，则返回此连接即将到期的时间：如果都是活跃连接并且大于 0，则返回默认的 keepAlive 时间 5 分钟。</span></span><br><span class="line">    <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="built_in">this</span>.keepAliveDurationNs</span><br><span class="line">        || idleConnectionCount &gt; <span class="built_in">this</span>.maxIdleConnections) &#123;</span><br><span class="line">      <span class="comment">// We&#x27;ve found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class="line">      <span class="comment">// of the synchronized block).</span></span><br><span class="line">      connections.remove(longestIdleConnection);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// A connection will be ready to evict soon.</span></span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// All connections are in use. It&#x27;ll be at least the keep alive duration &#x27;til we run again.</span></span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No connections, idle or in use.</span></span><br><span class="line">      cleanupRunning = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// 如果没有任何连接，则跳出循环并返回 -1.</span></span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  closeQuietly(longestIdleConnection.socket());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cleanup again immediately.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prunes any leaked transmitters and then returns the number of remaining live transmitters on</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> connection&#125;. Transmitters are leaked if the connection is tracking them but the</span></span><br><span class="line"><span class="comment"> * application code has abandoned them. Leak detection is imprecise and relies on garbage</span></span><br><span class="line"><span class="comment"> * collection.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">  List&lt;Reference&lt;Transmitter&gt;&gt; references = connection.transmitters;</span><br><span class="line">  <span class="comment">// 遍历传进来的 Transmitter，而不是以前版本的 RealConnection 的 StreamAllocation。</span></span><br><span class="line">  <span class="comment">// 如果 Transmitter 被使用，则接着遍历下一个 Transmitter，如果未被使用，则从列表中移除。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; references.size(); ) &#123;</span><br><span class="line">    Reference&lt;Transmitter&gt; reference = references.get(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reference.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;ve discovered a leaked transmitter. This is an application bug.</span></span><br><span class="line">    <span class="type">TransmitterReference</span> <span class="variable">transmitterRef</span> <span class="operator">=</span> (TransmitterReference) reference;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;A connection to &quot;</span> + connection.route().address().url()</span><br><span class="line">        + <span class="string">&quot; was leaked. Did you forget to close a response body?&quot;</span>;</span><br><span class="line">    Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace);</span><br><span class="line"></span><br><span class="line">    references.remove(i);</span><br><span class="line">    connection.noNewExchanges = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this was the last allocation, the connection is eligible for immediate eviction.</span></span><br><span class="line">    <span class="comment">// 如果列表为空，则说明此连接没有引用了，返回 0，表示此连接是空闲连接：</span></span><br><span class="line">    <span class="keyword">if</span> (references.isEmpty()) &#123;</span><br><span class="line">      connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则就返回非 0 的数,表示此连接是活跃连接.</span></span><br><span class="line">  <span class="keyword">return</span> references.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>使用类似于引用计数的方式跟踪 socket 流的调用.计数对象是 Transmitter,会被反复执行这两个方法,这其实是在改变 List&lt;Reference<Transmitter>&gt; 的大小.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">acquireConnectionNoEvents</span><span class="params">(RealConnection connection)</span> &#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.connection != <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">  <span class="built_in">this</span>.connection = connection;</span><br><span class="line">  connection.transmitters.add(<span class="keyword">new</span> <span class="title class_">TransmitterReference</span>(<span class="built_in">this</span>, callStackTrace));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove the transmitter from the connection&#x27;s list of allocations. Returns a socket that the</span></span><br><span class="line"><span class="comment"> * caller should close.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span> Socket <span class="title function_">releaseConnectionNoEvents</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(connectionPool));</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = <span class="built_in">this</span>.connection.transmitters.size(); i &lt; size; i++) &#123;</span><br><span class="line">    Reference&lt;Transmitter&gt; reference = <span class="built_in">this</span>.connection.transmitters.get(i);</span><br><span class="line">    <span class="keyword">if</span> (reference.get() == <span class="built_in">this</span>) &#123;</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index == -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">RealConnection</span> <span class="variable">released</span> <span class="operator">=</span> <span class="built_in">this</span>.connection;</span><br><span class="line">  released.transmitters.remove(index);</span><br><span class="line">  <span class="built_in">this</span>.connection = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (released.transmitters.isEmpty()) &#123;</span><br><span class="line">    released.idleAtNanos = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (connectionPool.connectionBecameIdle(released)) &#123;</span><br><span class="line">      <span class="keyword">return</span> released.socket();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a><p class="m_more_title_style">优势</p></h2><p>1、支持 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://baike.baidu.com/link?url=c068H6lCWKC4PrF97sC6h1FiisAfWHoaiNnvwcghaMhSeYdMI66LJaCvigJpDqX21Nv6UoiwSgGFIogI7akCdq">SPDY</a>，允许连接同一主机的所有请求分享一个socket。 如果SPDY不可用，会使用连接池减少请求延迟。<br>2、使用GZIP压缩下载内容，且压缩操作对用户是透明的。<br>3、利用响应缓存来避免重复的网络请求。<br>4、失败重试。如果服务端有多个IP地址，当第一个地址连接失败时，OKHttp会尝试连接其他备用地址，这对IPV4和IPV6以及寄宿在多个数据中心的服务而言，是非常有必要的。<br>5、对 http 协议的封装,比较底层,因此拓展性强,便于封装。<br>6、OKhttp 使用非阻塞  I&#x2F;O 模型 OKio (算是nio吧，和一般的nio不太一致，一般的nio定时去检查是否有数据到来，有的话就读，没有就返回，但是okio的实现是定时去检查是否已经读写完成，没完成就认为超时，close掉该socket)，该I&#x2F;O框架的内存表现也很好（mars使用epoll）。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><p class="m_more_title_style">链接</p></h2><p><strong>参考资料：</strong><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/cb444f49a777">彻底理解OkHttp</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/itachi85">Android 进阶之光</a></p>

    </div>

    
    
    

    <footer class="post-footer">
<div class="post-block">
	
    <div style="text-align:center;color:#696969;font-size:14px;">------------- 本 文 结 束 ❤️ 感 谢 阅 读 -------------</div>
    
</div>



          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="非也缘也 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpeg" alt="非也缘也 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>非也缘也
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://jianghouren.cn/archives/2efded73.html" title="OkHttp 源码">https://jianghouren.cn/archives/2efded73.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%BA%93%E4%B8%8E%E6%A1%86%E6%9E%B6/" rel="tag"># 库与框架</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/archives/86b9f0ef.html" rel="prev" title="系统软件配置">
                  <i class="fa fa-chevron-left"></i> 系统软件配置
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/archives/fc03f94d.html" rel="next" title="Retrofit 源码">
                  Retrofit 源码 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">非也缘也</span>
</div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div>
<span class="post-meta-item">

  	<span class="post-meta-item-icon">
	      <i class="fa fa-user"></i>
  	</span>
   <span>总访客&nbsp<span id="busuanzi_value_site_uv"></span>&nbsp人</span>
</span>

<span class="post-meta-item">
  	<span class="post-meta-item-icon">
	      <i class="fa fa-eye"></i>
  	</span>
   <span>总访问&nbsp<span id="busuanzi_value_site_pv"></span>&nbsp次</span>
</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>


  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://waline-git-main-feiyeyuanyes-projects.vercel.app/","placeholder":"请文明评论呀（填写邮箱可在被回复时收到邮件提醒）","avatar":"mm","pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/archives/2efded73.html"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>

  <script async src="https://imgsw.cn/js/cursorfireworks.js"></script>





<div class="read_cut diyclass" id="read_cut"></div>
<div class="skin_peeler diyclass" id="skin_peeler"></div>
<div class="read_aloud diyclass" id="read_aloud"></div>
<div class="audioImg diyclass" id="audioImg"></div>
<audio id="audioMp3" controls="true" loop="loop"></audio>
<script src="/js/my-diy.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":66,"vOffset":-60},"mobile":{"show":false,"scale":0.5},"react":{"opacity":0.5},"log":false});</script></body>
</html>
