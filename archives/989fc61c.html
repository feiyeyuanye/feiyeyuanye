<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

<link rel="preconnect" href="//fonts.loli.net" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic%7CJetBrains+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"jianghouren.cn","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#0593D3","save":"manual"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="article">
<meta property="og:title" content="Android 线程">
<meta property="og:url" content="https://jianghouren.cn/archives/989fc61c.html">
<meta property="og:site_name" content="非也缘也 Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jianghouren.cn/images/article_err_default.jpg">
<meta property="og:image" content="https://imgsw.cn/static/images/线程的状态.jpeg?imageView2/2/h/600">
<meta property="og:image" content="https://imgsw.cn/static/images/Java内存模型的抽象示意图.jpeg?imageView2/2/h/600">
<meta property="article:published_time" content="2019-11-04T02:59:26.000Z">
<meta property="article:modified_time" content="2022-07-13T08:56:22.669Z">
<meta property="article:author" content="非也缘也">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jianghouren.cn/images/article_err_default.jpg">


<link rel="canonical" href="https://jianghouren.cn/archives/989fc61c.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jianghouren.cn/archives/989fc61c.html","path":"archives/989fc61c.html","title":"Android 线程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android 线程 | 非也缘也 Blog</title>
  




<link rel="dns-prefetch" href="https://waline-git-main-feiyeyuanyes-projects.vercel.app/">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">非也缘也 Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Hello World</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">线程基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">1.2.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">阻塞队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">实现线程的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-Thread"><span class="nav-number">2.1.</span> <span class="nav-text">继承 Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-Callable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.2.</span> <span class="nav-text">实现 Callable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%88Java%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">示例（Java）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%88Kotlin%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">示例（Kotlin）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">主线程和子线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%BD%A2%E6%80%81"><span class="nav-number">4.</span> <span class="nav-text">Android 中线程形态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncTask%EF%BC%88Android-11-%E8%A2%AB%E5%BA%9F%E5%BC%83%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">AsyncTask（Android 11 被废弃）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncTask-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">AsyncTask 的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HandlerThread"><span class="nav-number">4.3.</span> <span class="nav-text">HandlerThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IntentService"><span class="nav-number">4.4.</span> <span class="nav-text">IntentService</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.</span> <span class="nav-text">Android 中的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">5.1.</span> <span class="nav-text">ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">5.2.</span> <span class="nav-text">线程池的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%80%E8%88%AC%E7%94%A8%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">线程池一般用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8"><span class="nav-number">6.</span> <span class="nav-text">备注</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="非也缘也"
      src="https://imgsw.cn/static/images/blog_portrait.jpeg">
  <p class="site-author-name" itemprop="name">非也缘也</p>
  <div class="site-description" itemprop="description">不可描述</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">202</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/feiyeyuanye" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;feiyeyuanye" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/10814718/feiyeyuanye" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;10814718&#x2F;feiyeyuanye" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/wu-wang-chu-xin-28/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;wu-wang-chu-xin-28&#x2F;" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-audible fa-fw"></i>LeetCode</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://developer.android.google.cn/" title="https:&#x2F;&#x2F;developer.android.google.cn&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">· Developers</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://wanandroid.com/" title="https:&#x2F;&#x2F;wanandroid.com&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">· WanAndroid</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://liuwangshu.cn/" title="https:&#x2F;&#x2F;liuwangshu.cn&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">· 刘望舒</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jianghouren.cn/archives/989fc61c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://imgsw.cn/static/images/blog_portrait.jpeg">
      <meta itemprop="name" content="非也缘也">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="非也缘也 Blog">
      <meta itemprop="description" content="不可描述">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android 线程 | 非也缘也 Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android 线程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-04 10:59:26" itemprop="dateCreated datePublished" datetime="2019-11-04T10:59:26+08:00">2019-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-13 16:56:22" itemprop="dateModified" datetime="2022-07-13T16:56:22+08:00">2022-07-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android-%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">Android 知识点</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/archives/989fc61c.html#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/archives/989fc61c.html" data-xid="/archives/989fc61c.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/archives/989fc61c.html" class="post-meta-item leancloud_visitors" data-flag-title="Android 线程" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  



    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>24 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <img data-src="https://imgsw.cn/static/images/动物狂想曲.jpeg" onerror="javascript:this.src='/images/article_err_default.jpg';" class="m_more_content_bg_img" />

<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><p><strong>什么是进程</strong></p>
<p>进程是操作系统结构的基础，是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的基本单元。进程可以被看作程序的实体，同样，它也是线程的容器。（Java 程序运行在 JVM 中，JVM 进程其实就是他们的容器。）</p>
<p>简单来讲，进程就是程序的实体，是受操作系统管理的基本运行单元。并且进程是重量级的，进程之间也是隔离的。</p>
<p> Android 基于 Linux，App 运行在沙箱机制，就是一个 App 独立运行在一个虚拟机中，即使出错也不会影响系统，所以每一个虚拟机，运行的过程叫做进程。</p>
<p><strong>什么是线程</strong></p>
<p>在操作系统中，程序里面运行的子任务就是线程，线程是 CPU 调度的最小单元，也叫作轻量级进程，同时它又是一种受限的系统资源（不可能无限制地产生，是有限的），并且线程的创建和销毁都会有相应的开销。</p>
<p>在一个进程中可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</p>
<p>当系统中存在大量的线程时，系统会通过时间片轮转的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数量小于等于 CPU 的核心数，一般来说这不可能。</p>
<p>线程优化：采用线程池，避免程序中存在大量的 Thread。</p>
<p><strong>进程与线程的区别</strong></p>
<p>进程是拥有资源的最小单位：word打开文件，QQ音乐打开了Socket。</p>
<p>线程是CPU调度的最小单位：T1线程接受文字输入，T2负责自动保存。T3线程负责从Socket读取数据，T4线程对音乐数据解码。</p>
<p>操作系统在做调度的时候基本单位不是word和QQ音乐这样的进程，而是T1、T2这种线程。</p>
<p>进程一般指一个执行单元，在 PC 和移动设备上指一个程序或者一个应用。它可包含多个线程。</p>
<p>线程，就是程序代码的执行，一个进程至少得有一个线程。每个线程执行的都是进程代码的某个片段。以word为例，如有定时保存文档的功能，当只有一个线程时，当这功能运行时，则无法输入文字。</p>
<p><strong>为什么要使用多线程</strong></p>
<p>在操作系统级别上来看主要有以下几个方面：</p>
<ul>
<li>使用多线程可以减少程序的响应时间。如果某个操作很耗时，或者陷入长时间的等待，此时程序将不会响应鼠标和键盘等的操作，使用多线程后可以把耗时的操作分配到一个单独的线程中去执行，从而使程序具备了更好的交互性。</li>
<li>与进程相比，线程创建和切换开销更小，同时多线程在数据共享方面效率非常高。</li>
<li>多 CPU 或者多核计算机本身就具备执行多线程的能力。如果使用单个线程，将无法重复利用计算机资源，这会造成资源的巨大浪费。在多 CPU 计算机中使用多线程能提高 CPU 的利用率。所以说，使用多线程不一定是为了提高效率，也许是为了发挥多核的优势，或者是更好的利用CPU快速的运算能力。</li>
<li>使用多线程能简化程序的结构，使程序便于理解和维护。</li>
</ul>
<p><strong>线程的状态</strong></p>
<p>Java 线程在运行的生命周期中可能会处于 6 种不同的状态：</p>
<ul>
<li>New：新创建状态。线程被创建，还没有调用 start 方法，在线程运行之前还有一些基础工作做要做。</li>
<li>Runnable：可运行状态。调用 start 方法后所处于的状态。此时可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。</li>
<li>Blocked：阻塞状态。表示线程被锁阻塞，它暂时不活动。（当线程调用到同步方法时，如果线程没有获得锁则进入阻塞状态，当阻塞状态的线程获取到锁时则重新回到运行状态。）</li>
<li>Waiting：等待状态。线程暂时不活动，并且不运行任何代码，这消耗最少的资源，直到线程调度器重新激活它。（需要等待其它线程通知才能返回运行状态）</li>
<li>Timed Waiting：超时等待状态。与等待状态不同的是，它可以在指定的时间自行返回。（相当于在等待状态加上了时间限制，如果超过了时间限制，则线程返回运行状态）</li>
<li>Terminated：终止状态。表示当前线程已经执行完毕。导致线程终止有两种情况。<ul>
<li>run 方法执行完毕正常退出。</li>
<li>因为一个没有捕获的异常而终止了 run 方法。</li>
</ul>
</li>
</ul>
<img data-src="https://imgsw.cn/static/images/线程的状态.jpeg?imageView2/2/h/600">

<p><strong>理解中断</strong></p>
<p>一个线程可通过 interrupt 方法来请求中断线程，此时线程的中断标识位将被置位（中断标识位为 true），线程会不时地检测这个中断标识位，以判断线程是否应该被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程是否被置位</span></span><br><span class="line"><span class="keyword">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以调用 Thread.interrupted() 来对中断标识位进行复位。但是如果一个线程被阻塞，就无法检测中断状态。因为处于阻塞状态时，如果线程在检查中断标识位时发现为 true，则会在阻塞方法调用处抛出 InterruptedException 异常，并且在抛出异常前将线程的中断标识位复位，即重新设置为 false。</p>
<p>需要注意的是，被中断的线程不一定会终止，中断线程是为了引起线程的注意，被中断的线程可以决定如何去响应中断。如果是比较重要的线程则不会理会中断，而大部分情况则是线程会将中断作为一个终止的请求。</p>
<p>另外，不要在底层代码里捕获到 InterruptedException 异常后不做处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">myTask</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面介绍两种合理的处理方式。</p>
<p>1、在 catch 子句中，调用 Thread.currentThread().interrupted() 来设置中断状态（因为抛出异常后中断标识位会复位），让外界通过判断 Thread.currentThread().isInterrupted() 来决定是否终止线程还是继续下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">myTask</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        Thread.currentThread().interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、更好的做法是，不使用 try catch 来捕获这样的异常，让方法直接抛出，这样调用者可以捕获这个异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">myTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>安全地终止线程</strong></p>
<p>1、使用中断来终止线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MoonRunner</span> <span class="variable">moonRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MoonRunner</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(moonRunner,<span class="string">&quot;MoonThread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 调用 sleep 方法使得 main 线程睡眠 10 ms，这是为了留给 MoonThread 线程时间来感知中断从而结束。</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印结果：</span></span><br><span class="line">        <span class="comment">// i = 1</span></span><br><span class="line">        <span class="comment">// i = 2</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// i = 699</span></span><br><span class="line">        <span class="comment">// i = 700</span></span><br><span class="line">        <span class="comment">// stop  // 执行到了 run 方法的末尾，线程即将终止。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MoonRunner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> i;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、采用 boolean 变量来控制是否需要停止线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MoonRunner</span> <span class="variable">moonRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MoonRunner</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(moonRunner,<span class="string">&quot;MoonThread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 调用 sleep 方法使得 main 线程睡眠 10 ms，这是为了留给 MoonThread 线程时间来感知中断从而结束。</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        moonRunner.cancel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印结果：</span></span><br><span class="line">        <span class="comment">// i = 1</span></span><br><span class="line">        <span class="comment">// i = 2</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// i = 714</span></span><br><span class="line">        <span class="comment">// i = 715</span></span><br><span class="line">        <span class="comment">// stop   // 执行到了 run 方法的末尾，线程即将终止。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MoonRunner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> i;</span><br><span class="line">        <span class="comment">// 因为涉及多个线程对这个变量的访问，所以在设置 volatile boolean on 的时候，</span></span><br><span class="line">        <span class="comment">// 当有其他线程改变其值时，所有的线程都会感知到它的变化。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">on</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (on)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span>&#123;</span><br><span class="line">            on = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>在多线程应用中，两个或两个以上的线程需要共享对同一个数据的存取。如果存取相同的对象，并且每一个线程都调用了修改该对象的方法，这种情况通常被称为竞争条件。</p>
<p>竞争条件最容易理解的例子为：比如车站售卖火车票，票数一定，但售卖窗口很多，每个窗口就相当于一个线程。这么多的线程共用所有的火车票资源，如果不使用同步是无法保证其原子性的。解决的办法如下：当一个线程要使用火车票这个资源时，就交给它一把锁，等它把事情做完后再把锁给另一个要用这个资源的线程。</p>
<p><strong>重入锁与条件对象</strong></p>
<p>synchronized 关键字自动提供了锁以及相关的条件。大多数需要显式锁的情况使用 synchronized 非常方便，而了解重入锁和条件对象时，能更好的地理解 synchronized 关键字。重入锁 ReentrantLock 是 Java SE 5.0 引入的，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。用 ReentrantLock 保护代码块的结构如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 当一个线程封锁了锁对象，其它任何线程都无法进入 Lock 语句。</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;...</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 在 finally 中进行解锁操作。</span></span><br><span class="line">  <span class="comment">// 意义在于，如果临界区发生了异常，锁是必须要释放的，否则其它线程将会永远被阻塞。</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一结构确保任何时刻只有一个线程进入临界区，临界区就是在同一时刻只能有一个任务访问的代码区。当进入临界区时，却发现在某个条件满足之后，它才能执行。这时可以使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程，条件对象又被称作条件变量。</p>
<p><strong>同步方法</strong></p>
<p>Lock 和 Condition 接口为程序设计人员提供了高度的锁定控制，然而大多数情况下，并不需要那样的控制，并且可以使用一种嵌入到 Java 语言内部的机制。从 Java 1.0 版开始，Java 中的每一个对象都有一个内部锁。如果一个方法用 synchronized 关键字声明，那么对象的锁将保护整个方法。也就是说，线程必须获得内部的对象锁。</p>
<p><strong>同步代码块</strong></p>
<p>每一个 Java 对象都有一个锁，线程可以调用同步方法来获得锁。而使用同步代码块，是另一种可以获得锁的机制。通常不推荐使用。</p>
<p><strong>volatile</strong></p>
<p>有时仅仅为了读写一个或者两个实例域就使用同步的话，显得开销过大。而 volatile 关键字为实力域的同步访问提供了免锁的机制。如果声明一个域为 volatile ，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。</p>
<p>首先了解下内存模型的相关概念，以及并发编程中的 3 个特性：原子性、可见性、有序性。</p>
<p>Java 内存模型</p>
<p>Java 中的堆内存用来存储对象实例，堆内存是被所有线程共享的运行时内存区域，因此，它存在内存可见性的问题。而局部变量、方法定义和参数则不会在线程之间共享，它们不会有内存可见性的问题，也不受内存模型的影响。Java 内存模型定义了线程和主存之间的抽象关系：线程之间的共享变量存储在主存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程共享变量的副本。需要注意的是本地内存是 Java 内存模型的一个抽象概念，其并不真实存在，它涵盖了缓存、写缓冲区、寄存器等区域。Java 内存模型控制线程之间的通信，它决定一个线程对主存共享变量的写入何时对另一个线程可见。</p>
<img data-src="https://imgsw.cn/static/images/Java内存模型的抽象示意图.jpeg?imageView2/2/h/600">

<p>线程 A 与 线程 B 之间若要通信，必须经历以下两个步骤：</p>
<ul>
<li><p>线程 A 把线程 A 本地内存中更新过的共享变量刷新到主存中去。</p>
</li>
<li><p>线程 B 到主存中去读取线程 A 之前已更新过的共享变量。由此可见，如果执行下面的语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行线程必须先在自己的工作线程中对变量 i 所在的缓存行进行赋值操作，然后再写入主存当中，而不是直接将数值 3 写入主存当中。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>原子性</p>
<p>对基本数据类型变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行完毕，要么就不执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有这条语句是原子性操作，其它两个语句都不是原子性操作。</span></span><br><span class="line">x = <span class="number">3</span>;  </span><br><span class="line"><span class="comment">// 包含了 2个操作：它先读取 x 的值，再将 x 的值写入工作内存。读取 x 的值以及将 x 的值写入工作内存这两个操作单拿出来都是原子性操作，但合起来就不是原子性操作了。 </span></span><br><span class="line">y = x;  </span><br><span class="line"><span class="comment">// 包括了 3 个操作：读取 x 的值，对 x 的值进行加 1，向工作内存写入新值。</span></span><br><span class="line">x++;    </span><br></pre></td></tr></table></figure>

<p>可知，一个语句含有多个操作时，就不是原子性操作，只有简单地读取和赋值（将数字赋值给某个变量）才是原子性操作。（java.util.concurrent.atomic 包中有很多类使用了很高效的机器级指令(而不是使用锁)来保证其他操作的原子性。例如 AtomicInteger 类提供了方法 incrementAndGet 和 decrementAndGet，它们分别以原子方式将一个整数自增和自减。可以安全地使用 AtomicInteger 类作为共享计数器而无需同步。另外这个包还包含 AtomicBoolean、AtomicLong 和 AtomicReference 这些原子类，这仅供开发并发工具的系统程序员使用，应用程序员不应该使用这些类。）</p>
<p>可见性</p>
<p>指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，另一个线程马上就能看到。当一个共享变量被 volatile 修饰时，它会保证修改的值立即被更新到主存，所以对其它线程是可见的。当有其它线程需要读取该值时，其它线程会去主存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，并不会立即被写入主存，何时被写入主存也是不确定的。当其他线程去读取该值时，此时主存中可能还是原来的旧值，这样就无法保证可见性。</p>
<p>有序性</p>
<p>Java 内存模型中允许编译器和处理器对指令进行重排序，虽然重排序过程不会影响到单线程执行的正确性，但是会影响到多线程并发执行的正确性。这时可通过 volatile 来保证有序性，除了 volatile，也可以通过 synchronize 和 Lock 来保证有序性。synchronize 和 Lock 保证每个时刻只有一个线程执行同步代码，这相当于是让线程顺序执行同步代码，从而保证了有序性。</p>
<p>volatile 关键字</p>
<p>当一个共享变量被 volatile 修饰之后，其就具备了两个含义，一个是线程修改了变量的值时，变量的新值对其它线程是立即可见的。换句话说，就是不同线程对这个变量进行操作时具有可见性。另一个含义是禁止使用指令重排序。（重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序分为两类：编译器重排序和运行期重排序，分别对应编译时和运行时环境。）</p>
<p>volatile 不保证原子性，保证有序性。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列（BlockingQueue）常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<hr>
<h2 id="实现线程的方式"><a href="#实现线程的方式" class="headerlink" title="实现线程的方式"></a><p class="m_more_title_style">实现线程的方式</p></h2><p>一般实现线程的方法有 3 种，其中前两种最为常用：</p>
<ul>
<li>继承 Thread ，并重写 run 方法。</li>
<li>实现 Runnable 接口，并实现该接口的 run 方法。</li>
<li>实现 Callable 接口，并重写 call 方法。</li>
</ul>
<p>一般推荐用实现 Runnable 接口的方式，其原因是，一个类应该在其需要加强或修改时才会被继承。因此如果没有必要重写 Thread 类的其他方法，那么在这种情况下最好用实现 Runnable 接口的方式。而且 Java 是单继承但可以调用多个接口，所以看起来实现接口更加好一些。</p>
<h3 id="继承-Thread"><a href="#继承-Thread" class="headerlink" title="继承 Thread"></a>继承 Thread</h3><p>Thread 本质上也是实现了 Runnable 接口的一个实例。需要注意当调用 start 方法后并不是立即执行线程的代码，而是使线程变为可运行状态，什么时候运行代码是由操作系统决定的。其主要步骤如下：</p>
<ul>
<li>定义 Thread 类的子类，并重写该类的 run 方法，该 run 方法的方法体就代表了线程要完成的任务。因此，run 方法被称为执行体。</li>
<li>创建 Thread 子类的实例，即创建了线程对象。</li>
<li>调用线程对象的 start 方法来启动该线程。</li>
</ul>
<p>###实现 Runnable 接口</p>
<p>其主要步骤如下：</p>
<ul>
<li>自定义类并实现 Runnable 接口，实现 run 方法。</li>
<li>创建 Thread 子类的实例，用实现 Runnable 接口的对象作为参数实例化该 Thread 对象。</li>
<li>调用 Thread 的 start 方法来启动该线程。</li>
</ul>
<h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><p>Callable 接口实际是属于 Executor 框架中的功能类，Callable 接口与 Runnable 接口的功能类似，但提供了比 Runnable 更强大的功能，主要表现为以下 3 点：</p>
<ul>
<li>Callable 可以在任务接受后提供一个返回值，而 Runnable 无法提供这个功能。</li>
<li>Callable 中的 call 方法可以抛出异常，而 Runnable 的 run 方法不能抛出异常。</li>
<li>运行 Callable 可以拿到一个 Future 对象，Future 对象表示异步计算的结果，它提供了检查计算是否完成的方法。由于线程属于异步计算模型，因此无法从别的线程中得到函数的返回值，在这种情况下就可以使用 Future 来监视目标线程调用 call 方法的情况。但调用 Future 的 get 方法以获取结果时，当前线程就会阻塞，直到 call 方法返回结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCallable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建线程类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTestCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyTestCallable</span> <span class="variable">myTestCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTestCallable</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> executorService.submit(myTestCallable);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 等待线程结束，并返回结果。</span></span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例（Java）"><a href="#示例（Java）" class="headerlink" title="示例（Java）"></a>示例（Java）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 继承 Thread</span></span><br><span class="line">        <span class="type">ExtendsThread</span> <span class="variable">extendsThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExtendsThread</span>();</span><br><span class="line">        <span class="comment">// 当调用 Thread 时，会有两种方式：</span></span><br><span class="line">        <span class="comment">// run()方法只是调用了 Thread 实例的 run() 方法而已，它仍然运行在主线程上。</span></span><br><span class="line">        <span class="comment">// start()方法会开辟一个新的线程，在新的线程上调用 run() 方法，此时它运行在新的线程上。</span></span><br><span class="line">        extendsThread.start();    <span class="comment">// 运行结果：1</span></span><br><span class="line">        extendsThread.run();      <span class="comment">// 运行结果：658</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现 Runnable 接口</span></span><br><span class="line">        <span class="type">ImplementsThread</span> <span class="variable">implementsThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImplementsThread</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(implementsThread).start();   <span class="comment">// 运行结果：659</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现 Callable 接口</span></span><br><span class="line">        <span class="comment">// Thread 类只支持 Runnable 接口，由此引入 FutureTask 的概念</span></span><br><span class="line">        <span class="comment">// 运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。</span></span><br><span class="line">        <span class="comment">// 它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。</span></span><br><span class="line">        <span class="comment">// 通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果；</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">CallableThread</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableThread</span>();</span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        executor.shutdown();     <span class="comment">// 运行结果：660</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// FutureTask 实现了 Runnable 和 Future，所以兼顾两者优点，</span></span><br><span class="line">        <span class="comment">// 既可以在 Thread 中使用，又可以在 ExecutorService 中使用。</span></span><br><span class="line">        <span class="comment">// 它可以让程序员准确地知道线程什么时候执行完成并获得到线程执行完成后返回的结果。</span></span><br><span class="line">        <span class="comment">// FutureTask 是一种可以取消的异步的计算任务，它的计算是通过 Callable 实现的，</span></span><br><span class="line">        <span class="comment">// 它等价于可以携带结果的 Runnable，并且有三个状态：等待、运行和完成。</span></span><br><span class="line">        <span class="comment">// 完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。</span></span><br><span class="line">        <span class="comment">// 第一种方式</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor1</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">CallableThread</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">CallableThread</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(task1);</span><br><span class="line">        executor1.submit(futureTask);</span><br><span class="line">        executor1.shutdown();     <span class="comment">// 运行结果：661</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种方式，注意这种方式和第一种方式效果是类似的，</span></span><br><span class="line">        <span class="comment">// 只不过一个使用的是ExecutorService，一个使用的是Thread</span></span><br><span class="line">        <span class="type">CallableThread</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableThread</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(task2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2);</span><br><span class="line">        thread.start();   <span class="comment">// 运行结果：662</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;CallableThread结果：&quot;</span>+result.get());         <span class="comment">// 运行结果：1</span></span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;CallableThread结果：&quot;</span>+futureTask.get());     <span class="comment">// 运行结果：1</span></span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;CallableThread结果：&quot;</span>+futureTask2.get());    <span class="comment">// 运行结果：1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 Thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ExtendsThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.run();</span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;ExtendsThread：&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 Runnable 接口</span></span><br><span class="line"><span class="comment">     * JDK 1.0 增加</span></span><br><span class="line"><span class="comment">     * Thread 调用了 Runnable 接口中的方法用来在线程中执行任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ImplementsThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;ImplementsThread：&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 Callable 接口</span></span><br><span class="line"><span class="comment">     * Callable 一般是和 ExecutorService 配合来使用的</span></span><br><span class="line"><span class="comment">     * JDK1.5 增加</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 相比较 Runnable 接口:</span></span><br><span class="line"><span class="comment">     * Callable 接口下的方法是 call()，Runnable 接口的方法是 run()；</span></span><br><span class="line"><span class="comment">     * Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的；</span></span><br><span class="line"><span class="comment">     * call() 方法可以抛出异常，run()方法不可以的；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">CallableThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;CallableThread：&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例（Kotlin）"><a href="#示例（Kotlin）" class="headerlink" title="示例（Kotlin）"></a>示例（Kotlin）</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadActivity</span> : <span class="type">BaseActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_thread)</span><br><span class="line"></span><br><span class="line">        initView()</span><br><span class="line">        initData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个整型变量，用来表示更新 TextView 这个动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> updateText = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        btnChangeText.setOnClickListener&#123;</span><br><span class="line">            <span class="keyword">val</span> msg = Message()</span><br><span class="line">            msg.what = updateText</span><br><span class="line">            <span class="comment">// 将 Message 对象发送出去</span></span><br><span class="line">            handler.sendMessage(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增一个 Handler 对象，并重写父类的 handleMessage()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> handler = <span class="keyword">object</span> : Handler()&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">            <span class="comment">// 进行 UI 操作</span></span><br><span class="line">            <span class="keyword">when</span>(msg.what)&#123;</span><br><span class="line">                updateText -&gt; tvText.text = <span class="string">&quot;Nice to meet you&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initData</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        MyThread().start()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> myThread = MyThread2()</span><br><span class="line">        <span class="comment">// Thread 构造函数接收一个 Runnable 参数</span></span><br><span class="line">        Thread(myThread).start()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不想专门定义一个类去实现 Runnable 接口，</span></span><br><span class="line">        <span class="comment">// 可以使用 Lambda 的方式，这种写法更为常见。</span></span><br><span class="line">        Thread&#123;</span><br><span class="line">            <span class="comment">// 编写具体的逻辑</span></span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;匿名 Thread is start。&quot;</span>)</span><br><span class="line">        &#125;.start()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Kotlin 提供了一种更加简单的开启线程的方式，</span></span><br><span class="line">        <span class="comment">// 这里的 Thread 是一个 Kotlin 内置的顶层函数，</span></span><br><span class="line">        <span class="comment">// 只需要在 Lambda 表达式中编写具体的逻辑即可。</span></span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="comment">// 编写具体的逻辑</span></span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;Kotlin Thread is start。&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建类继承自 Thread，并重新父类的 run()。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>:<span class="type">Thread</span></span>()&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.run()</span><br><span class="line">            <span class="comment">// 编写的逻辑</span></span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;类继承 Thread is start。&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更加推荐使用实现 Runnable 接口的方式来定义一个线程，</span></span><br><span class="line"><span class="comment">     * 因为继承的方式耦合性有点高。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span>:<span class="type">Runnable&#123;</span></span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 编写的逻辑</span></span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,<span class="string">&quot;实现接口 Thread is start。&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">actionStart</span><span class="params">(context: <span class="type">Context</span>)</span></span>&#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(context, ThreadActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            context.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a><p class="m_more_title_style">主线程和子线程</p></h2><p>从用途上来说，线程分为主线程（主要处理和界面相关的事情）和子线程（往往用于执行耗时操作）。</p>
<p>主线程是指进程所拥有的线程，在 Java 中默认一个进程只有一个线程，即主线程。子线程也叫工作线程，除主线程以外的线程都是子线程。</p>
<p>Android 沿用了 Java 的线程模型，其中主线程也叫 UI 线程，作用是运行四大组件以及处理它们和用户的交互，因为所有的UI控件操作都在UI线程中执行，用户随时会和界面发生交互，因此主线程要有较高的响应速度。如果在主线程执行耗时任务，会阻塞UI线程，甚至导致ANR错误，所以对耗时任务需要创建工作线程来执行。而子线程的作用就是执行耗时任务。</p>
<p>Android中哪些场景是执行在主线程的?<br>1、Activity生命周期回调都是执行在主线程的.<br>2、Service默认是执行在主线程的.<br>3、BroadcastReceiver的onReceive回调是执行在主线程的.<br>4、没有使用子线程的looper的Handler的handleMessage, post(Runnable)是执行在主线程的.<br>5、AsyncTask的回调中除了doInBackground, 其他都是执行在主线程的.<br>6、View的post(Runnable)是执行在主线程的.等等</p>
<p>Android开发中何时使用多进程？使用多进程的好处是什么？<br>要想知道如何使用多进程，先要知道Android里的多进程概念。一般情况下，一个应用程序就是一个进程，这个进程名称就是应用程序包名。我们知道进程是系统分配资源和调度的基本单位，所以每个进程都有自己独立的资源和内存空间，别的进程是不能任意访问其他进程的内存和资源的。</p>
<p>那如何让自己的应用拥有多个进程？<br>很简单，我们的四大组件在AndroidManifest文件中注册的时候，有个属性是android:process，<br>1.这里可以指定组件的所处的进程。默认就是应用的主进程。指定为别的进程之后，系统在启动这个组件的时候，就先创建（如果还没创建的话）这个进程，然后再创建该组件。你可以重载Application类的onCreate方法，打印出它的进程名称，就可以清楚的看见了。再设置android:process属性时候，有个地方需要注意：如果是android:process&#x3D;”:deamon”，以:开头的名字，则表示这是一个应用程序的私有进程，否则它是一个全局进程。私有进程的进程名称是会在冒号前自动加上包名，而全局进程则不会。一般我们都是有私有进程，很少使用全局进程。他们的具体区别不知道有没有谁能补充一下。<br>2.使用多进程显而易见的好处就是分担主进程的内存压力。我们的应用越做越大，内存越来越多，将一些独立的组件放到不同的进程，它就不占用主进程的内存空间了。当然还有其他好处，有心人会发现Android后台进程里有很多应用是多个进程的，因为它们要常驻后台，特别是即时通讯或者社交应用，不过现在多进程已经被用烂了。典型用法是在启动一个不可见的轻量级私有进程，在后台收发消息，或者做一些耗时的事情，或者开机启动这个进程，然后做监听等。还有就是防止主进程被杀守护进程，守护进程和主进程之间相互监视，有一方被杀就重新启动它。应该还有还有其他好处，这里就不多说了。<br>3.坏处的话，多占用了系统的空间，大家都这么用的话系统内存很容易占满而导致卡顿。消耗用户的电量。应用程序架构会变复杂，应为要处理多进程之间的通信。这里又是另外一个问题了。</p>
<hr>
<h2 id="Android-中线程形态"><a href="#Android-中线程形态" class="headerlink" title="Android 中线程形态"></a><p class="m_more_title_style">Android 中线程形态</p></h2><p>除了 Thread 本身以外，在 Android 中充当线程的角色还有 AsyncTask、HandlerThread、IntentService。它们本质上都是由 Handler + Thread 来构成的（AsyncTask 的底层用到了线程池），不过不同的设计让它们可以在不同的场合发挥更好的作用。</p>
<ul>
<li>AsyncTask：封装了线程池和 Handler，主要为了方便开发者在子线程中更新 UI。</li>
<li>HandlerThread：是一种具有消息循环队列的线程，可以方便在子线程中处理不同的事务，在它的内部可使用 Handler。</li>
<li>IntentService：是一个服务，系统对其封装使其可以更方便地执行后台任务，IntentService 内部采用 HandlerThread 来执行任务，任务完毕后 IntentService 会自动退出。它的优势在于不易被系统杀死。</li>
</ul>
<h3 id="AsyncTask（Android-11-被废弃）"><a href="#AsyncTask（Android-11-被废弃）" class="headerlink" title="AsyncTask（Android 11 被废弃）"></a>AsyncTask（Android 11 被废弃）</h3><p>为了更加方便我们在子线程中对 UI 进行操作，Android 还提供了另外一些好用的工具，比如 AsyncTask。</p>
<p>是一种轻量级的异步任务类，它可在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程中更新 UI。其封装了 Thread 和 Handler。并且不适合做特别耗时的后台任务。</p>
<p>AsyncTask 是一个抽象的泛型类，提供了 3 个泛型参数，如不需要可用 Void 代替：</p>
<ul>
<li>Params：在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。</li>
<li>Progress：在后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。</li>
<li>Result：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。</li>
</ul>
<p>AsyncTask 的四个核心方法，执行顺序如下：</p>
<ul>
<li>onPreExecute()：主线程中执行，会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框。</li>
<li>doInBackground(Params…params)：子线程中运行，在线程池中执行，此方法用于异步耗时任务，params 参数表示异步任务的输入参数。在此方法中可通过 publishProgress() 来更新任务的进度，publishProgress() 会调用 onProgressUpdate()。另外此方法需要返回计算结果给 onPostExecute()。</li>
<li>onProgressUpdate(Progress…values)：在主线程中执行，当在后台任务中调用 publishProgress() 后，执行进度改变时此方法会快会被调用，该方法中携带的参数就是在后台任务中传递过来的。</li>
<li>onPostExecute(Result…result)：在主线程中执行，在异步任务执行之后，此方法会被调用，其中 result 参数是后台任务的返回值， 即 doInBackground 的返回值。当 onCancelled()（主线程执行，异步任务取消时）被调用时，此方法不会被调用。</li>
</ul>
<p>AsyncTask 在具体使用过程中的限制：</p>
<ul>
<li>第一次访问 AsyncTask 必须在主线程，不过这个过程在 Android 4.1 及以上版本中已经被系统自动完成。</li>
<li>AsyncTask 的对象必须在主线程中创建。</li>
<li>execute() 必须在 UI 线程调用。</li>
<li>不要在程序中直接调用四个方法。</li>
<li>一个 AsyncTask 对象只能执行一次，即只能调用一次 execute()。</li>
<li>在 Android 1.6 之前和 Android 3.0 开始（可通过 executeOnExecutor() 并行执行任务），AsyncTask 是串行执行任务的。Android 1.6 时开始采用线程池里处理并行任务。</li>
</ul>
<p>示例（Java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AsyncTask 是一个抽象泛型类，</span></span><br><span class="line"><span class="comment"> * 声明：public abstract class AsyncTask&lt;Params, Progress, Result&gt;;</span></span><br><span class="line"><span class="comment"> * 参数1，Params，异步任务的入参；</span></span><br><span class="line"><span class="comment"> * 参数2，Progress，执行任务的进度；</span></span><br><span class="line"><span class="comment"> * 参数3，Result，后台任务执行的结果；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title class_">AsyncTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAsyncTask</span><span class="params">(String mName)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mName = mName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在主线程中执行，任务开启前的准备工作；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPreExecute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPreExecute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启子线程执行后台任务；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TargetApi(Build.VERSION_CODES.N)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">doInBackground</span><span class="params">(Object[] objects)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        Log.e(mName, dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis())));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在主线程中执行，更新UI进度；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onProgressUpdate</span><span class="params">(Object[] values)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onProgressUpdate(values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在主线程中执行，</span></span><br><span class="line"><span class="comment">     * 异步任务执行完成后执行，</span></span><br><span class="line"><span class="comment">     * 它的参数是 doInbackground() 的返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPostExecute</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPostExecute(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        initAsyncTask();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initAsyncTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 串行</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">MyAsyncTask</span>(<span class="string">&quot;MyAsyncTask01&quot;</span>)).execute();</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">MyAsyncTask</span>(<span class="string">&quot;MyAsyncTask02&quot;</span>)).execute();</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">MyAsyncTask</span>(<span class="string">&quot;MyAsyncTask03&quot;</span>)).execute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并行</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">MyAsyncTask</span>(<span class="string">&quot;MyAsyncTask04&quot;</span>)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">MyAsyncTask</span>(<span class="string">&quot;MyAsyncTask05&quot;</span>)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">MyAsyncTask</span>(<span class="string">&quot;MyAsyncTask06&quot;</span>)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// E/MyAsyncTask01: 2019-06-27 15:13:46</span></span><br><span class="line">        <span class="comment">// E/MyAsyncTask06: 2019-06-27 15:13:46</span></span><br><span class="line">        <span class="comment">// E/MyAsyncTask04: 2019-06-27 15:13:46</span></span><br><span class="line">        <span class="comment">// E/MyAsyncTask05: 2019-06-27 15:13:46</span></span><br><span class="line">        <span class="comment">// E/MyAsyncTask02: 2019-06-27 15:13:47</span></span><br><span class="line">        <span class="comment">// E/MyAsyncTask03: 2019-06-27 15:13:48</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例（Kotlin）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Unit 表示在执行 AsyncTask 时不需要传入参数给后台任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Int 表示使用整型数据来作为进度显示单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Boolean 表示使用布尔型数据来反馈执行结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用 AsyncTask 的诀窍就是：</span></span><br><span class="line"><span class="comment"> * 在 doInBackground() 中执行具体的耗时任务，</span></span><br><span class="line"><span class="comment"> * 在 onProgressUpdate() 中进行 UI 操作。</span></span><br><span class="line"><span class="comment"> * 在 onPostExecute() 中执行一些任务的收尾工作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 启动这个任务：DownloadTask.execute()</span></span><br><span class="line"><span class="comment"> * 并且可以传入任意数量的参数，这些参数将会传递到 DownloadTask 的 doInBackground() 中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span>: <span class="type">AsyncTask</span>&lt;<span class="type">Unit, Int, Boolean</span>&gt;</span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreExecute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        progressDialog.show() <span class="comment">// 显示进度对话框</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行具体的下载任务，在子线程中运行。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 如果 AsyncTask 的第三个泛型参数指定的是 Unit，就可以不返回任务执行结果。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 当下载完成后，会返回一个布尔型变量，onPostExecute() 很快被调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doInBackground</span><span class="params">(<span class="keyword">vararg</span> params: <span class="type">Unit</span>?)</span></span> = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> downloadPercent = doDownload()  <span class="comment">// 这是一个虚构方法，用于计算当前的下载进度并返回。</span></span><br><span class="line">            <span class="comment">// 得到进度后，调用方法并传入当前的下载进度，这样 onProgressUpdate() 很快会被调用。</span></span><br><span class="line">            <span class="comment">// 切换线程</span></span><br><span class="line">            publishProgress(downloadPercent)</span><br><span class="line">            <span class="keyword">if</span> (downloadPercent &gt;= <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e:Exception)&#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行 UI 操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onProgressUpdate</span><span class="params">(<span class="keyword">vararg</span> values: <span class="type">Int</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在这里更新下载进度</span></span><br><span class="line">        progressDialog.setMessage(<span class="string">&quot;Downloaded <span class="subst">$&#123;values[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPostExecute</span><span class="params">(result: <span class="type">Boolean</span>?)</span></span> &#123;</span><br><span class="line">        progressDialog.dismiss()  <span class="comment">// 关闭进度对话框</span></span><br><span class="line">        <span class="comment">// 在这里提示下载结果</span></span><br><span class="line">        <span class="keyword">if</span> (result)&#123;</span><br><span class="line">            Toast.makeText(content,<span class="string">&quot;Download succeeded&quot;</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Toast.makeText(content,<span class="string">&quot;Download failed&quot;</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AsyncTask-的工作原理"><a href="#AsyncTask-的工作原理" class="headerlink" title="AsyncTask 的工作原理"></a>AsyncTask 的工作原理</h3><p>execute() –&gt; executeOnExecutor():</p>
<ul>
<li>executeOnExecutor()<br>sDefaultExecutor 是一个串行的线程池，一个进程中所有的 AsyncTask 全部在其中排队执行。<br>会先执行 onPreExecute()，然后线程池开始执行。</li>
<li>线程池 SerialExecutor<br>首先会把 Params 参数封装为 FutureTask 对象，它是一个并发类，这里充当 Runnable 的作用。<br>接着这个 FutureTask 会交给 execute() 处理，会把它插入到任务队列 mTasks 中，这时如果没有正在活动的 AsyncTask 任务，会调用 scheduleNext() 执行下一个 AsyncTask 任务。<br>同时当一个 AsyncTask 任务执行完毕后，会继续执行其他任务，直到所有任务都被执行为止。</li>
</ul>
<p>AsyncTask 中有两个线程池和一个 Handler：</p>
<ul>
<li>SerialExecutor：用于任务的排队</li>
<li>THREAD_POOL_EXECUTOR：用于真正地执行任务</li>
<li>InternalHandler：用于将执行环境从线程池切换到主线程</li>
</ul>
<p>在 AsyncTask 的构造方法中，FutureTask 的 run() 会调用 mWorker 的 call()，因此 call() 最终在线程池中执行：</p>
<ul>
<li>call()<br>将 mTaskInvoked 设为 true，表示当前任务已经被调用过了，然后执行 AsyncTask 的 doInBackground 方法，接着将其返回值传递给 postResult()。</li>
<li>postResult()<br>会通过 sHandler 发送一个 MESSAGE_POST_RESULT 的消息。</li>
<li>sHandler 的定义<br>一个静态的 Handler 对象，为了能够将执行环境切换到主线程，sHandler 必须在主线程中创建。<br>由于静态成员会在加载类的时候进行初始化，因此这就变相要求 AsyncTask 的类也必须在主线程中加载，否则同一个进程中的 AsyncTask 都无法正常工作。<br>收到 MESSAGE_POST_RESULT 消息后，会调用 AsyncTask 的 finish()。</li>
<li>finish()<br>如果 AsyncTask 被取消执行了，就调用 onCancelled()，否则调用 onPostExecute()，可看到 doInBackground 的返回结果会传递给 onPostExecute()。<br>到这里，AsyncTask 的整个工作过程就完毕了。</li>
</ul>
<h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><p>继承了 Thread，实际上是一个允许使用 Handler的特殊线程。外界需要通过 Handler 的方式来通知它执行一个具体的任务。</p>
<p>普通线程在 run() 方法中执行耗时操作，而 HandlerThread 在 run() 方法创建了一个消息队列不停地轮询消息，可通过 Handler 发送消息来告诉线程该执行什么操作。</p>
<p>它在 run() 中通过 Looper.prepare() 来创建消息队列，并通过 Looper.loop() 来开启消息循环：</p>
<ul>
<li>run()<br>是一个无限循环，因此当不再使用 HandlerThread 时，可通过调用 quit() 或 quitSafely() 来终止线程的执行。</li>
</ul>
<p>它常见的使用场景是在 IntentService 中。当不再需要 HandlerThread 时，通过调用 quit&#x2F;Safely 方法来结束线程的轮询并结束该线程。</p>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>一种特殊的 Service，它是一个继承 Service 的抽象类，所以必须实现它的子类再去使用。</p>
<p>IntentService 可以理解为它是一个实现了 HandlerThread 的 Service。</p>
<p>因为 Service 的优先级比较高，可以利用这个特性来保证后台服务的优先正常执行，甚至还可以为Service开辟一个新的进程。并且任务执行后会自动停止。</p>
<p>当第一次启动时，onCreate() 会被调用：</p>
<ul>
<li>onCreate()<br>会创建一个 HandlerThread，然后使用它的 Looper 来构造一个 Handler 对象 mServiceHandler，这样通过 mServiceHandler 发送的消息最终都会在 HandlerThread 中执行。</li>
</ul>
<p>每次启动 IntentService，它的 onStartCommand() 就会调用一次，其中处理每个后台任务的 Intent：</p>
<ul>
<li>onStartCommand()<br>调用了 onStart()。</li>
<li>onStart()<br>通过 mServiceHandler 发送了一个消息，会在 HandlerThread 中被处理。</li>
</ul>
<p>mServiceHandler 收到消息后，会将 Intent 对象传递给 onHandleIntent()（一个抽象方法，需要在子类实现，它的作用是从 Intent 参数中区分具体的任务并执行这些任务）去处理，当 onHandleIntent() 执行结束后，IntentService 会通过 stopSelf(int startId)（区别于 stopSelf() 会立刻停止服务，它会等待所有消息处理完毕后才终止服务） 来尝试停止服务。</p>
<hr>
<h2 id="Android-中的线程池"><a href="#Android-中的线程池" class="headerlink" title="Android 中的线程池"></a>Android 中的线程池</h2><p>池：同类对象的批量管理。</p>
<p>线程池：用少量线程，让线程保持忙碌。（线程处理完任务，回到线程池中等待，不结束。）</p>
<p>线程可以预先创建，让它进入阻塞状态，等待任务在唤醒。<br>BlockingQueue：</p>
<ul>
<li>take()-&gt;取数据-&gt;如果这Queue中没数据-&gt;则会阻塞</li>
<li>put()-&gt;放数据-&gt;如果这Queue中满了-&gt;则会阻塞</li>
<li>线程的run()中设置一个循环，每次从BlockingQueue中获取任务，空的则会阻塞，有消息通知线程池的某一线程处理，并且依然从Queue中获取任务。</li>
</ul>
<p>一个线程池中会缓存一定数量的线程，通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。Android 中的线程池来源于 Java，主要通过 Executor 来派生特定类型的线程池。</p>
<p><strong>它的优点</strong>：</p>
<ul>
<li>重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。</li>
<li>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象。</li>
<li>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ul>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>它是线程池的真正实现，它的构造方法提供了一系列参数来配置线程池。<br>ExecutorService 是最初的线程池接口，ThreadPoolExecutor 类是对线程池的具体实现，它通过构造方法来配置线程池的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* corePoolSize</span></span><br><span class="line"><span class="comment">* 线程池中核心线程的数量，</span></span><br><span class="line"><span class="comment">* 默认情况下，即使核心线程没有任务在执行它也存在的，</span></span><br><span class="line"><span class="comment">* 我们固定一定数量的核心线程且它一直存活这样就避免了一般情况下CPU创建和销毁线程带来的开销。</span></span><br><span class="line"><span class="comment">* 我们如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程就会有超时策略，这个时间由keepAliveTime来设定，</span></span><br><span class="line"><span class="comment">* 即keepAliveTime时间内如果核心线程没有回应则该线程就会被终止。allowCoreThreadTimeOut默认为false，核心线程没有超时时间。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* maximumPoolSize</span></span><br><span class="line"><span class="comment">* 线程池中的最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。</span></span><br><span class="line"><span class="comment">* 最大线程数=核心线程+非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* keepAliveTime</span></span><br><span class="line"><span class="comment">* 非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。</span></span><br><span class="line"><span class="comment">* 当allowCoreThreadTimeOut设置为true时，此属性也作用在核心线程上。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* unit</span></span><br><span class="line"><span class="comment">* 枚举时间单位，TimeUnit。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* workQueue</span></span><br><span class="line"><span class="comment">* 线程池中的任务队列，我们提交给线程池的runnable会被存储在这个对象上。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>它执行任务时的大致规则</strong>：</p>
<ol>
<li>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li>
<li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li>
<li>如果在步骤 2 中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li>
<li>如果步骤 3 中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor 会调用 RejectedExecutionHandler 的 rejectedExecution() 来通知调用者。</li>
</ol>
<h3 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h3><p>一些不同特性的线程池，它们都直接或者间接通过 ThreadPoolExecutor 来实现自己的功能<br><strong>Android 中常见的四类线程池</strong>：</p>
<ul>
<li><strong>FixedThreadPool</strong>：<br>通过 Executors 的 newFixedThreadPool() 来创建。它是一种线程数量固定的线程池，当线程处于空闲状态时，它们并不会被回收，除非线程池被关闭了。当所有的线程都处于活动状态时，新任务都会处于等待状态，直到有线程空闲出来。它能更快的响应外界请求。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">通过 Executors 的 newFixedThreadPool() 方法创建，</span></span><br><span class="line"><span class="comment">它是个线程数量固定的线程池，该线程池的线程全部为核心线程，</span></span><br><span class="line"><span class="comment">它们没有超时机制且排队任务队列无限制，因为全都是核心线程，所以响应较快，且不用担心线程会被回收。</span></span><br><span class="line"><span class="comment">参数 nThreads，就是固定的核心线程数量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>CachedThreadPool</strong>：<br>是一种线程数量不定的线程池，它只有非核心线程，并且其最大线程数为 Integer.MAX_VALUE（很大的数）。当线程池中的线程都处于活动状态时，线程池会创建新的线程来处理新任务，否则就会利用空闲的线程来处理新任务。空闲线程都有超时机制（60 秒），超过就会被回收。它的任务队列相当于一个空集合，导致任何任务都会被立即执行。适合执行大量的耗时较少的任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">通过Executors的newCachedThreadPool()方法来创建，</span></span><br><span class="line"><span class="comment">它是一个数量无限多的线程池，它所有的线程都是非核心线程，</span></span><br><span class="line"><span class="comment">当有新任务来时如果没有空闲的线程则直接创建新的线程不会去排队而直接执行，并且超时时间都是60s，所以此线程池适合执行大量耗时小的任务。</span></span><br><span class="line"><span class="comment">由于设置了超时时间为60s，所以当线程空闲一定时间时就会被系统回收，所以理论上该线程池不会有占用系统资源的无用线程。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>ScheduledThreadPool</strong>：<br>它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收。主要用于执行定时任务和具有固定周期的重复任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">通过Executors的newScheduledThreadPool()方法来创建，</span></span><br><span class="line"><span class="comment">ScheduledThreadPool线程池像是上两种的合体，它有数量固定的核心线程，且有数量无限多的非核心线程，</span></span><br><span class="line"><span class="comment">但是它的非核心线程超时时间是0s，所以非核心线程一旦空闲立马就会被回收。</span></span><br><span class="line"><span class="comment">这类线程池适合用于执行定时任务和固定周期的重复任务。</span></span><br><span class="line"><span class="comment">参数corePoolSize是核心线程数量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure></li>
<li><strong>SingleThreadExecutor</strong>：<br>这类线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中按顺序执行。它的意义在于统一所有的外界任务到一个线程中，这使得在这些任务之间不需要处理线程同步的问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">通过Executors的newSingleThreadExecutor()方法来创建，</span></span><br><span class="line"><span class="comment">它内部只有一个核心线程，它确保所有任务进来都要排队按顺序执行。</span></span><br><span class="line"><span class="comment">它的意义在于，统一所有的外界任务到同一线程中，让调用者可以忽略线程同步问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线程池一般用法"><a href="#线程池一般用法" class="headerlink" title="线程池一般用法"></a>线程池一般用法</h3><ul>
<li>shutDown()：关闭线程池，需要执行完已提交的任务。</li>
<li>shutDownNow()：关闭线程池，并尝试结束已提交的任务。</li>
<li>allowCoreThreadTimeOut(boolen)：允许核心线程闲置超时回收。</li>
<li>execute()：提交任务无返回值。接收一个Runnable对象作为参数，异步执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;myRunnable&quot;</span>, <span class="string">&quot;run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">mExecutor.execute(myRunnable);</span><br></pre></td></tr></table></figure></li>
<li>submit()：提交任务有返回值。</li>
</ul>
<hr>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p><strong>参考资料：</strong></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://bbs.xiangxueketang.cn/news/detail/1056">线程池的好处</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://guolin.blog.csdn.net/article/details/105233078">第一行代码(第3版)</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/singwhatiwanna">Android 开发艺术探索</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/itachi85">Android 进阶之光</a></p>
<details class="m_more_content_details">
  <summary  class="m_more_content_summary">单词音标：</summary>
  <ul>
      <li>fixed  英  [fɪkst]   美  [fɪkst]</li>
      <li>cached  英  [kæʃt]   美  [kæʃt]</li>
      <li>scheduled  英  ['ʃedjuːld]   美  [ˈskedʒuːld]</li>
      <li>single  英  [ˈsɪŋɡl]   美  [ˈsɪŋɡl]</li>
      <li>async  英  [əˈsɪŋk]   美  [æˈsɪŋk]</li>
      <li>executor  英  [ɪɡˈzekjətə(r)]   美  [ɪɡˈzekjətər]</li>
  </ul>
</details>
    </div>

    
    
    

    <footer class="post-footer">
<div class="post-block">
	
    <div style="text-align:center;color:#696969;font-size:14px;">------------- 本 文 结 束 ❤️ 感 谢 阅 读 -------------</div>
    
</div>



          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="非也缘也 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpeg" alt="非也缘也 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>非也缘也
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://jianghouren.cn/archives/989fc61c.html" title="Android 线程">https://jianghouren.cn/archives/989fc61c.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/archives/ab7d7f79.html" rel="prev" title="Handler 运行机制">
                  <i class="fa fa-chevron-left"></i> Handler 运行机制
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/archives/9ae0256a.html" rel="next" title="Bitmap 的加载和 Cache">
                  Bitmap 的加载和 Cache <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">非也缘也</span>
</div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div>
<span class="post-meta-item">

  	<span class="post-meta-item-icon">
	      <i class="fa fa-user"></i>
  	</span>
   <span>总访客&nbsp<span id="busuanzi_value_site_uv"></span>&nbsp人</span>
</span>

<span class="post-meta-item">
  	<span class="post-meta-item-icon">
	      <i class="fa fa-eye"></i>
  	</span>
   <span>总访问&nbsp<span id="busuanzi_value_site_pv"></span>&nbsp次</span>
</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>


  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://waline-git-main-feiyeyuanyes-projects.vercel.app/","placeholder":"请文明评论呀（填写邮箱可在被回复时收到邮件提醒）","avatar":"mm","pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/archives/989fc61c.html"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>

  <script async src="https://imgsw.cn/js/cursorfireworks.js"></script>





<div class="read_cut diyclass" id="read_cut"></div>
<div class="skin_peeler diyclass" id="skin_peeler"></div>
<div class="read_aloud diyclass" id="read_aloud"></div>
<div class="audioImg diyclass" id="audioImg"></div>
<audio id="audioMp3" controls="true" loop="loop"></audio>
<script src="/js/my-diy.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":66,"vOffset":-60},"mobile":{"show":false,"scale":0.5},"react":{"opacity":0.5},"log":false});</script></body>
</html>
