<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

<link rel="preconnect" href="//fonts.loli.net" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic%7CJetBrains+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"jianghouren.cn","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#0593D3","save":"manual"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="article">
<meta property="og:title" content="Android Binder原理（一）">
<meta property="og:url" content="https://jianghouren.cn/archives/8b4d12b5.html">
<meta property="og:site_name" content="非也缘也 Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jianghouren.cn/images/article_err_default.jpg">
<meta property="og:image" content="https://imgsw.cn/static/images/nzNJUA.png?imageView2/2/h/600">
<meta property="og:image" content="https://imgsw.cn/static/images/n5i5PP.png?imageView2/2/h/600">
<meta property="og:image" content="https://imgsw.cn/static/images/uZgTgJ.png?imageView2/2/h/600">
<meta property="og:image" content="https://imgsw.cn/static/images/uMegMj.png?imageView2/2/h/600">
<meta property="og:image" content="https://imgsw.cn/static/images/ufWhRI.png?imageView2/2/h/600">
<meta property="og:image" content="https://imgsw.cn/static/images/Ka0Dx0.png?imageView2/2/h/600">
<meta property="og:image" content="https://imgsw.cn/static/images/MgRMbF.png?imageView2/2/h/600">
<meta property="og:image" content="https://imgsw.cn/static/images/MgWuRI.png?imageView2/2/h/600">
<meta property="og:image" content="https://imgsw.cn/static/images/MTmhzd.png?imageView2/2/h/600">
<meta property="og:image" content="https://imgsw.cn/static/images/Qud4yt.png?imageView2/2/h/600">
<meta property="article:published_time" content="2020-09-13T21:42:44.000Z">
<meta property="article:modified_time" content="2020-10-02T01:28:49.000Z">
<meta property="article:author" content="非也缘也">
<meta property="article:tag" content="通信机制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jianghouren.cn/images/article_err_default.jpg">


<link rel="canonical" href="https://jianghouren.cn/archives/8b4d12b5.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://jianghouren.cn/archives/8b4d12b5.html","path":"archives/8b4d12b5.html","title":"Android Binder原理（一）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android Binder原理（一） | 非也缘也 Blog</title>
  




<link rel="dns-prefetch" href="https://waline-git-main-feiyeyuanyes-projects.vercel.app/">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">非也缘也 Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Hello World</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServiceManager%E4%B8%AD%E7%9A%84Binder%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">ServiceManager中的Binder机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EBinder%E9%80%9A%E4%BF%A1%E7%9A%84C-x2F-S%E6%9E%B6%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">基于Binder通信的C&#x2F;S架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MediaServer%E7%9A%84main%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">MediaServer的main函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%94%AF%E4%B8%80%E7%9A%84ProcessState"><span class="nav-number">2.3.</span> <span class="nav-text">每个进程唯一的ProcessState</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceManager%E4%B8%AD%E7%9A%84Binder%E6%9C%BA%E5%88%B6-1"><span class="nav-number">2.4.</span> <span class="nav-text">ServiceManager中的Binder机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BpBinder%E5%92%8CBBinder"><span class="nav-number">2.4.1.</span> <span class="nav-text">BpBinder和BBinder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%AF%86IServiceManager"><span class="nav-number">2.4.2.</span> <span class="nav-text">解密IServiceManager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IServiceManager%E5%AE%B6%E6%97%8F"><span class="nav-number">2.4.3.</span> <span class="nav-text">IServiceManager家族</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E8%8A%82"><span class="nav-number">2.5.</span> <span class="nav-text">小节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">系统服务的注册过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E8%B0%83%E7%94%A8%E9%93%BE%E8%A7%92%E5%BA%A6%E8%AF%B4%E6%98%8EMediaPlayerService%E6%98%AF%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E7%9A%84"><span class="nav-number">3.1.</span> <span class="nav-text">从调用链角度说明MediaPlayerService是如何注册的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#writeTransactionData%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-number">3.1.1.</span> <span class="nav-text">writeTransactionData函数分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#waitForResponse%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-number">3.1.2.</span> <span class="nav-text">waitForResponse函数分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E8%8A%82-1"><span class="nav-number">3.1.3.</span> <span class="nav-text">小节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E8%BF%9B%E7%A8%8B%E8%A7%92%E5%BA%A6%E8%AF%B4%E6%98%8EMediaPlayerService%E6%98%AF%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E7%9A%84"><span class="nav-number">3.2.</span> <span class="nav-text">从进程角度说明MediaPlayerService是如何注册的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServiceManager%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">ServiceManager的启动过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceManager%E7%9A%84%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">ServiceManager的入口函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80binder%E8%AE%BE%E5%A4%87"><span class="nav-number">4.1.1.</span> <span class="nav-text">打开binder设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E6%88%90%E4%B8%BABinder%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E8%80%85"><span class="nav-number">4.1.2.</span> <span class="nav-text">注册成为Binder机制的上下文管理者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E5%92%8C%E5%A4%84%E7%90%86client%E7%AB%AF%E5%8F%91%E6%9D%A5%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="nav-number">4.1.3.</span> <span class="nav-text">循环等待和处理client端发来的请求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%8E%B7%E5%8F%96%E8%BF%87%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">系统服务的获取过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AFMediaPlayerService%E8%AF%B7%E6%B1%82%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1"><span class="nav-number">5.1.</span> <span class="nav-text">客户端MediaPlayerService请求获取服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFServiceManager%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="nav-number">5.2.</span> <span class="nav-text">服务端ServiceManager处理请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-Binder%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">6.</span> <span class="nav-text">Java Binder的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Binder%E7%9A%84JNI%E6%B3%A8%E5%86%8C"><span class="nav-number">6.1.</span> <span class="nav-text">Java Binder的JNI注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binder%E7%B1%BB%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-number">6.2.</span> <span class="nav-text">Binder类的注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BinderInternal%E7%B1%BB%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-number">6.3.</span> <span class="nav-text">BinderInternal类的注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BinderProxy%E7%B1%BB%E7%9A%84%E6%B3%A8%E5%86%8C"><span class="nav-number">6.4.</span> <span class="nav-text">BinderProxy类的注册</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-Binder%E4%B8%AD%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">Java Binder中系统服务的注册过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86AMS%E6%B3%A8%E5%86%8C%E5%88%B0ServiceManager"><span class="nav-number">7.1.</span> <span class="nav-text">将AMS注册到ServiceManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BinderInternal-getContextObject"><span class="nav-number">7.2.</span> <span class="nav-text">BinderInternal.getContextObject()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceManagerNative-asInterface"><span class="nav-number">7.3.</span> <span class="nav-text">ServiceManagerNative.asInterface()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getIServiceManager-addService"><span class="nav-number">7.4.</span> <span class="nav-text">getIServiceManager().addService()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%87%BAJavaBBinder"><span class="nav-number">7.5.</span> <span class="nav-text">引出JavaBBinder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90JavaBBinder"><span class="nav-number">7.6.</span> <span class="nav-text">解析JavaBBinder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-Binder%E6%9E%B6%E6%9E%84"><span class="nav-number">7.7.</span> <span class="nav-text">Java Binder架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8"><span class="nav-number">8.</span> <span class="nav-text">备注</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="非也缘也"
      src="https://imgsw.cn/static/images/blog_portrait.jpeg">
  <p class="site-author-name" itemprop="name">非也缘也</p>
  <div class="site-description" itemprop="description">不可描述</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">202</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/feiyeyuanye" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;feiyeyuanye" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/10814718/feiyeyuanye" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;10814718&#x2F;feiyeyuanye" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode-cn.com/u/wu-wang-chu-xin-28/" title="LeetCode → https:&#x2F;&#x2F;leetcode-cn.com&#x2F;u&#x2F;wu-wang-chu-xin-28&#x2F;" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-audible fa-fw"></i>LeetCode</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://developer.android.google.cn/" title="https:&#x2F;&#x2F;developer.android.google.cn&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">· Developers</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://wanandroid.com/" title="https:&#x2F;&#x2F;wanandroid.com&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">· WanAndroid</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://liuwangshu.cn/" title="https:&#x2F;&#x2F;liuwangshu.cn&#x2F;" rel="noopener external nofollow noreferrer" target="_blank">· 刘望舒</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jianghouren.cn/archives/8b4d12b5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://imgsw.cn/static/images/blog_portrait.jpeg">
      <meta itemprop="name" content="非也缘也">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="非也缘也 Blog">
      <meta itemprop="description" content="不可描述">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android Binder原理（一） | 非也缘也 Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android Binder原理（一）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-14 05:42:44" itemprop="dateCreated datePublished" datetime="2020-09-14T05:42:44+08:00">2020-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-10-02 09:28:49" itemprop="dateModified" datetime="2020-10-02T09:28:49+08:00">2020-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android-%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="url" rel="index"><span itemprop="name">Android 知识点</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/archives/8b4d12b5.html#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/archives/8b4d12b5.html" data-xid="/archives/8b4d12b5.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span id="/archives/8b4d12b5.html" class="post-meta-item leancloud_visitors" data-flag-title="Android Binder原理（一）" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  



    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>56k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>51 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <img data-src="https://imgsw.cn/static/images/wallhaven-j5mr6w_1200x600.png" onerror="javascript:this.src='/images/article_err_default.jpg';" class="m_more_content_bg_img" />

<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><p class="m_more_title_style">简介</p></h2><p>Binder是基于开源的OpenBinder实现的，OpenBinder最早并不是由Google公司开发的，而是Be Inc公司开发的，接着由Palm, Inc.公司负责开发。后来OpenBinder的作者Dianne Hackborn加入了Google公司，并负责Android平台的开发工作，顺便把这项技术也带进了Android。</p>
<p>Binder是基于内存映射来实现的，在前面我们知道内存映射通常是用在有物理介质的文件系统上的，Binder没有物理介质，它使用内存映射是为了跨进程传递数据。</p>
<p>Binder 原理是掌握系统底层原理的基石。</p>
<ul>
<li>直观来说，Bindr 是 Android 中的一个类，它实现了 IBinder 接口。</li>
<li>从 IPC 角度来说，是 Android 中的一种跨进程通信方式。</li>
<li>还可以理解为一种虚拟的物理设备，它的设备驱动是 &#x2F;dev&#x2F;binder，该通信方式在 Linux 中没有。</li>
<li>从 Android Framework 角度来说，是 ServiceManager 连接各种 Manager 和相应 ManagerService 的桥梁。</li>
<li>从 Android 应用层来说，是客户端和服务端进行通信的媒介，当 bindService 时，服务端会返回一个包含了服务端业务调用的 Binder 对象，通过这个 Binder 对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于 AIDL 的服务。</li>
</ul>
<img data-src="https://imgsw.cn/static/images/nzNJUA.png?imageView2/2/h/600">

<p>Binder通信的步骤如下所示。<br>1.Binder驱动在内核空间创建一个数据接收缓存区。<br>2.在内核空间开辟一块内核缓存区，建立内核缓存区和数据接收缓存区之间的映射关系，以及数据接收缓存区和接收进程用户空间地址的映射关系。<br>3.发送方进程通过copy_from_user()函数将数据拷贝 到内核中的内核缓存区，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</p>
<p>整个过程只使用了1次拷贝，不会因为不知道数据的大小而浪费空间或者时间，效率更高。</p>
<p><strong>Binder 的工作机制：</strong></p>
<ul>
<li>客户端发起远程请求给 Binder。</li>
<li>Binder（内部类 Stub）写入参数（如果有参数）到 data 中。</li>
<li>接着调用 transact 方法发起 RPC（远程过程调用）请求，同时线程被挂起。</li>
<li>然后服务端的 onTransact 方法会被调用，会从 data 中取出目标方法所需参数（如果目标方法有参数），最终向 reply 中写入结果（如果有返回值）。</li>
<li>然后返回数据，唤醒 Client。</li>
</ul>
<p><strong>Binder 的死亡代理：</strong><br>Binder 运行在服务端进程，当服务端进程由于某种原因异常终止，这个时候我们到服务端的 Binder 连接断裂（称之为 Binder 死亡），会导致远程调用失败。<br>可通过 linkToDeath 和 unlinkToDeath 来实现。为 Binder 设置一个死亡代理。</p>
<p><strong>为什么要使用Binder</strong></p>
<p>Android是基于Linux内核的 ，Linux提供了很多IPC机制，而Android却自己设计了Binder来进行通信，主要是因为以下几点。<br><strong>性能方面</strong><br>性能方面主要影响的因素是拷贝次数，管道、消息队列、Socket的拷贝次书都是两次，性能不是很好，共享内存不需要拷贝，性能最好，Binder的拷贝次书为1次，性能仅次于内存拷贝。<br><strong>稳定性方面</strong><br>Binder是基于C&#x2F;S架构的，这个架构通常采用两层结构，在技术上已经很成熟了，稳定性是没有问题的。共享内存没有分层，难以控制，并发同步访问临界资源时，可能还会产生死锁。从稳定性的角度讲，Binder是优于共享内存的。<br><strong>安全方面</strong><br>Android是一个开源的系统，并且拥有开放性的平台，市场上应用来源很广，因此安全性对于Android 平台而言极其重要。<br>传统的IPC接收方无法获得对方可靠的进程用户ID&#x2F;进程ID（UID&#x2F;PID），无法鉴别对方身份。Android 为每个安装好的APP分配了自己的UID，通过进程的UID来鉴别进程身份。另外，Android系统中的Server端会判断UID&#x2F;PID是否满足访问权限，而对外只暴露Client端，加强了系统的安全性。<br><strong>语言方面</strong><br>Linux是基于C语言，C语言是面向过程的，Android应用层和Java Framework是基于Java语言，Java语言是面向对象的。Binder本身符合面向对象的思想，因此作为Android的通信机制更合适不过。</p>
<p>从这四方面来看，Linux提供的大部分IPC机制根本无法和Binder相比较，而共享内存只在性能方面优于Binder，其他方面都劣于Binder，这些就是为什么Android要使用Binder来进行进程间通信，当然系统中并不是所有的进程通信都是采用了Binder，而是根据场景选择最合适的，比如Zygote进程与AMS通信使用的是Socket，Kill Process采用的是信号。</p>
<p><strong>为什么要学习Binder</strong></p>
<p>Binder机制在Android中的地位举足轻重，我们需要掌握的很多原理都和Binder有关：</p>
<ol>
<li>系统中的各个进程是如何通信的？</li>
<li>Android系统启动过程</li>
<li>AMS、PMS的原理</li>
<li>四大组件的原理，比如Activity是如何启动的？</li>
<li>插件化原理</li>
<li>系统服务的Client端和Server端是如何通信的？（比如MediaPlayer和MeidaPlayerService)</li>
</ol>
<p>上面只是列了一小部分，简单来说说，比如系统在启动时，SystemServer进程启动后会创建Binder线程池，目的是通过Binder，使得在SystemServer进程中的服务可以和其他进程进行通信了。再比如我们常说的AMS、PMS都是基于Binder来实现的，拿PMS来说，PMS运行在SystemServer进程，如果它想要和DefaultContainerService通信（是用于检查和复制可移动文件的系统服务），就需要通过Binder，因为DefaultContainerService运行在com.android.defcontainer进程。<br>还有一个比较常见的C&#x2F;S架构间通信的问题，Client端的MediaPlayer和Server端的MeidaPlayerService不是运行在一个进程中的，同样需要Binder来实现通信。</p>
<p>可以说Binder机制是掌握系统底层原理的基石。根据Android系统的分层，Binder机制主要分为以下几个部分，其中Java Binder和Native Binder都是应用开发需要掌握的。Java Binder是需要借助Native Binder来工作的，因此需要先了解Native Binder，Native Binder架构的原型就是基于Binder通信的C&#x2F;S架构。</p>
<img data-src="https://imgsw.cn/static/images/n5i5PP.png?imageView2/2/h/600">

<h2 id="ServiceManager中的Binder机制"><a href="#ServiceManager中的Binder机制" class="headerlink" title="ServiceManager中的Binder机制"></a><p class="m_more_title_style">ServiceManager中的Binder机制</p></h2><h3 id="基于Binder通信的C-x2F-S架构"><a href="#基于Binder通信的C-x2F-S架构" class="headerlink" title="基于Binder通信的C&#x2F;S架构"></a><strong>基于Binder通信的C&#x2F;S架构</strong></h3><p>在Android系统中，Binder进程间的通信的使用是很普遍的，比如MediaPlayer框架基于C&#x2F;S架构，并采用Binder来进行进程间通信，如下图所示。</p>
<img data-src="https://imgsw.cn/static/images/uZgTgJ.png?imageView2/2/h/600">

<p>从图中可以看出，除了常规C&#x2F;S架构的Client端和Server端，还包括了ServiceManager，它用于管理系统中的服务。<br>首先Server进程会注册一些Service到ServiceManager中，Client要使用某个Service，则需要先到ServiceManager查询Service的相关信息，然后根据Service的相关信息与Service所在的Server进程建立通信通路，这样Client就可以使用Service了。</p>
<h3 id="MediaServer的main函数"><a href="#MediaServer的main函数" class="headerlink" title="MediaServer的main函数"></a><strong>MediaServer的main函数</strong></h3><p>Client、Server、ServiceManager三者的交互都是基于Binder通信的，那么任意两者的交互都可以说明Binder的通信的原理，可以说Native Binder的原理的核心就是ServiceManager的原理，为了更好的了解ServiceManager，这里拿MediaPlayer框架来举例，它也是学习多媒体时必须要掌握的知识点。MediaPlayer框架的简单框架图如下所示。</p>
<img data-src="https://imgsw.cn/static/images/uMegMj.png?imageView2/2/h/600">

<p>可以看到，MediaPlayer和MediaPlayerService是通过Binder来进行通信的，MediaPlayer是Client端，MediaPlayerService是Server端，MediaPlayerService是系统多媒体服务的一种，系统多媒体服务是由一个叫做MediaServer的服务进程提供的，它是一个可执行程序，在Android系统启动时，MediaServer也被启动，它的入口函数如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/av/media/mediaserver/main_mediaserver.cpp">main_mediaserver.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc __unused, <span class="type">char</span> **argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGPIPE, SIG_IGN);</span><br><span class="line">    <span class="comment">// 获取ProcessState实例，在这一过程中会打开/dev/binder设备，并使用mmap为Binder驱动分配一个虚拟地址空间用来接收数据。</span></span><br><span class="line">    <span class="function">sp&lt;ProcessState&gt; <span class="title">proc</span><span class="params">(ProcessState::self())</span></span>;</span><br><span class="line">    <span class="comment">// 用来得到一个IServiceManager，通过这个IServiceManager，其他进程就可以和当前的ServiceManager进行交互，这里就用到了Binder通信。</span></span><br><span class="line">    <span class="function">sp&lt;IServiceManager&gt; <span class="title">sm</span><span class="params">(defaultServiceManager())</span></span>;</span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.<span class="built_in">get</span>());</span><br><span class="line">    <span class="built_in">InitializeIcuOrDie</span>();</span><br><span class="line">    <span class="comment">// 注册MediaPlayerService</span></span><br><span class="line">    MediaPlayerService::<span class="built_in">instantiate</span>();</span><br><span class="line">    ResourceManagerService::<span class="built_in">instantiate</span>();</span><br><span class="line">    <span class="built_in">registerExtensions</span>();</span><br><span class="line">    <span class="comment">// 启动Binder线程池</span></span><br><span class="line">    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">    <span class="comment">// 当前线程加入到线程池</span></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="每个进程唯一的ProcessState"><a href="#每个进程唯一的ProcessState" class="headerlink" title="每个进程唯一的ProcessState"></a><strong>每个进程唯一的ProcessState</strong></h3><p>ProcessState用于代表进程的状态，在MediaServer的入口函数中调用了ProcessState::self()，查看ProcessState的self函数。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/libs/binder/ProcessState.cpp">ProcessState.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">  <span class="comment">// 这里采用了单例模式，确保每个进程只有一个ProcessState实例。</span></span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 通过 ProcessState 的构造函数来创建一个 ProcessState 实例，参数为/dev/binder。</span></span><br><span class="line">    gProcess = <span class="keyword">new</span> <span class="built_in">ProcessState</span>(<span class="string">&quot;/dev/binder&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着来查看ProcessState的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="type">const</span> <span class="type">char</span> *driver)</span><br><span class="line">    : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver))</span><br><span class="line">    , <span class="built_in">mDriverFD</span>(<span class="built_in">open_driver</span>(driver))  <span class="comment">// 此函数用来打开/dev/binder设备。</span></span><br><span class="line">    , <span class="built_in">mVMStart</span>(MAP_FAILED)</span><br><span class="line">    , <span class="built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mExecutingThreadsCount</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , <span class="built_in">mStarvationStartTimeMs</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mManagesContexts</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextCheckFunc</span>(<span class="literal">NULL</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextUserData</span>(<span class="literal">NULL</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolStarted</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolSeq</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// mmap函数，它会在内核虚拟地址空间中申请一块与用户虚拟内存相同大小的内存，然后再申请物理内存，将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，实现了内核虚拟地址空间和用户虚拟内存空间的数据同步操作，也就是内存映射。</span></span><br><span class="line">      <span class="comment">// mmap函数用于对Binder设备进行内存映射，除了它还有open、ioctl函数。</span></span><br><span class="line">mmap函数用于对Binder设备进行内存映射，除了它还有open、ioctl函数，来看看它们做了什么。</span><br><span class="line">        mVMStart = <span class="built_in">mmap</span>(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Using %s failed: unable to mmap transaction memory.\n&quot;</span>, mDriverName.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mDriverFD &lt; <span class="number">0</span>, <span class="string">&quot;Binder driver could not be opened.  Terminating.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看打开&#x2F;dev&#x2F;binder设备的open_driver函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">open_driver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 用于打开/dev/binder设备并返回文件操作符fd，这样就可以操作内核的Binder驱动了。</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">      <span class="comment">// ioctl函数的作用就是和Binder设备进行参数的传递，这里的ioctl函数用于设定binder支持的最大线程数为15（maxThreads的值为15）。</span></span><br><span class="line">        result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to set max threads failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Opening &#x27;%s&#x27; failed: %s\n&quot;</span>, driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 返回文件操作符fd。</span></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ProcessState总的来说它做了以下几个重要的事：<br>1.打开&#x2F;dev&#x2F;binder设备并设定Binder最大的支持线程数。<br>2.通过mmap为binder分配一块虚拟地址空间，达到内存映射的目的。</p>
<h3 id="ServiceManager中的Binder机制-1"><a href="#ServiceManager中的Binder机制-1" class="headerlink" title="ServiceManager中的Binder机制"></a><strong>ServiceManager中的Binder机制</strong></h3><p>在MediaServer的入口函数中调用了defaultServiceManager函数。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/libs/binder/IServiceManager.cpp">IServiceManager.cpp</a>。</p>
<p>从IServiceManager所在的文件路径就可以知道，其中不仅仅使用了Binder通信，它自身也是属于Binder体系的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IServiceManager&gt; <span class="title">defaultServiceManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 使用了单例</span></span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// interface_cast函数生成了gDefaultServiceManager，其内部调用了ProcessState的getContextObject函数。</span></span><br><span class="line">            gDefaultServiceManager = <span class="built_in">interface_cast</span>&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">NULL</span>));</span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getContextObject</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 直接调用了getStrongProxyForHandle函数，注意它的参数的值为0，那么handle的值就为0，handle是一个资源标识。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getStrongProxyForHandle</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="type">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"><span class="comment">// 查询 hanlde 这个资源标识对应的资源（handle_entry）是否存在。</span></span><br><span class="line">    handle_entry* e = <span class="built_in">lookupHandleLocked</span>(handle);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;<span class="built_in">attemptIncWeak</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新建BpBinder，并赋值给 handle_entry 的 binder。</span></span><br><span class="line">            b = BpBinder::<span class="built_in">create</span>(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;<span class="built_in">getWeakRefs</span>();</span><br><span class="line">            <span class="comment">// 最终返回的result的值为BpBinder。</span></span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;<span class="built_in">decWeak</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BpBinder和BBinder"><a href="#BpBinder和BBinder" class="headerlink" title="BpBinder和BBinder"></a><strong>BpBinder和BBinder</strong></h4><p>它们是Binder通信的“双子星”，都继承了IBinder。BpBinder是Client端与Server交互的代理类，而BBinder则代表了Server端。BpBinder和BBinder是一一对应的，BpBinder会通过handle来找到对应的BBinder。（在ServiceManager中创建了BpBinder，通过handle(值为0)可以找到对应的BBinder。）</p>
<p>回到interface_cast函数，其具体实现如下。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/libs/binder/include/binder/IInterface.h">IInterface.h</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; <span class="title">interface_cast</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INTERFACE::<span class="built_in">asInterface</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前的场景中，INTERFACE的值为IServiceManager，那么替换后代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> sp&lt;IServiceManager&gt; <span class="title">interface_cast</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">return</span> IServiceManager::<span class="built_in">asInterface</span>(obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解密IServiceManager"><a href="#解密IServiceManager" class="headerlink" title="解密IServiceManager"></a><strong>解密IServiceManager</strong></h4><p>BpBinder和BBinder负责Binder的通信，而 IServiceManager 用于处理 ServiceManager 的业务。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/libs/binder/include/binder/IServiceManager.h">IServiceManager.h</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* IServiceManager 继承了 IInterface，其内部定义了一些常量和一些操作 Service 的函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IServiceManager</span> : <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 调用了 DECLARE_META_INTERFACE 宏，它的定义在IInterface.h中。</span></span><br><span class="line">    <span class="built_in">DECLARE_META_INTERFACE</span>(ServiceManager)</span><br><span class="line">    ... <span class="comment">// 一些操作 Service 的函数。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt;         <span class="title">getService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt;         <span class="title">checkService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">addService</span><span class="params">(<span class="type">const</span> String16&amp; name, <span class="type">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">bool</span> allowIsolated = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_DEFAULT)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector&lt;String16&gt; <span class="title">listServices</span><span class="params">(<span class="type">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_ALL)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">        CHECK_SERVICE_TRANSACTION,</span><br><span class="line">        ADD_SERVICE_TRANSACTION,</span><br><span class="line">        LIST_SERVICES_TRANSACTION,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>查看 IInterface.h。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/libs/binder/include/binder/IInterface.h">IInterface.h</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="title function_">DECLARE_META_INTERFACE</span><span class="params">(INTERFACE)</span>                               \</span><br><span class="line">    <span class="keyword">static</span> const ::android::String16 descriptor;                        \</span><br><span class="line">    <span class="keyword">static</span> ::android::sp&lt;I##INTERFACE&gt; asInterface(                     \</span><br><span class="line">            const ::android::sp&lt;::android::IBinder&gt;&amp; obj);              \</span><br><span class="line">    virtual const ::android::String16&amp; getInterfaceDescriptor() const;  \</span><br><span class="line">    I##INTERFACE();                                                     \</span><br><span class="line">    virtual ~I##INTERFACE();                                            \</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 其中 INTERFACE 的值为 ServiceManager，那么经过替换后的代码如下所示。</span></span><br><span class="line">#define <span class="title function_">DECLARE_META_INTERFACE</span><span class="params">(INTERFACE)</span>                               </span><br><span class="line">    <span class="keyword">static</span> const ::android::String16 descriptor;    </span><br><span class="line"><span class="comment">//定义asInterface函数</span></span><br><span class="line">    <span class="keyword">static</span> ::android::sp&lt;IServiceManager&gt; <span class="title function_">asInterface</span><span class="params">(                     </span></span><br><span class="line"><span class="params">            const ::android::sp&lt;::android::IBinder&gt;&amp; obj)</span>;              </span><br><span class="line">    virtual const ::android::String16&amp; getInterfaceDescriptor() const;  </span><br><span class="line"><span class="comment">//定义IServiceManager构造函数</span></span><br><span class="line">    IServiceManager();         </span><br><span class="line"><span class="comment">//定义IServiceManager析构函数</span></span><br><span class="line">    virtual ~IServiceManager();       </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 DECLARE_META_INTERFACE 宏的名称和上面的代码中，可以发现它主要声明了一些函数和一个变量。那么这些函数和变量的实现在哪呢？答案还是在IInterface.h中，叫做 IMPLEMENT_META_INTERFACE宏，代码如下所示。</span></span><br><span class="line">#define <span class="title function_">IMPLEMENT_META_INTERFACE</span><span class="params">(INTERFACE, NAME)</span>                       \</span><br><span class="line">    const ::android::String16 I##INTERFACE::descriptor(NAME);           \</span><br><span class="line">    const ::android::String16&amp;                                          \</span><br><span class="line">            I##INTERFACE::getInterfaceDescriptor() const &#123;              \</span><br><span class="line">        <span class="keyword">return</span> I##INTERFACE::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    ::android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(              \</span><br><span class="line">            const ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        ::android::sp&lt;I##INTERFACE&gt; intr;                               \</span><br><span class="line">        <span class="keyword">if</span> (obj != NULL) &#123;                                              \</span><br><span class="line">            intr = static_cast&lt;I##INTERFACE*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        I##INTERFACE::descriptor).get());               \</span><br><span class="line">            <span class="keyword">if</span> (intr == NULL) &#123;                                         \</span><br><span class="line">                intr = <span class="keyword">new</span> <span class="title class_">Bp</span>##INTERFACE(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">return</span> intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span><br><span class="line">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DECLARE_META_INTERFACE 宏和 IMPLEMENT_META_INTERFACE 宏是配合使用的，很多系统服务都使用了它们，IServiceManager 使用 IMPLEMENT_META_INTERFACE 宏只有一行代码，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(ServiceManager, <span class="string">&quot;android.os.IServiceManager&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>IMPLEMENT_META_INTERFACE 宏的 INTERFACE 值为 ServiceManager，NAME 值为 ”android.os.IServiceManager”，进行替换后的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="title function_">IMPLEMENT_META_INTERFACE</span><span class="params">(INTERFACE, NAME)</span>                       </span><br><span class="line">    const ::android::String16 IServiceManager::descriptor(”android.os.IServiceManager”);           </span><br><span class="line">    const ::android::String16&amp;                                          </span><br><span class="line">            IServiceManager::getInterfaceDescriptor() const &#123;              </span><br><span class="line">        <span class="keyword">return</span> IServiceManager::descriptor;                                </span><br><span class="line">    &#125;     </span><br><span class="line"><span class="comment">// 实现了asInterface函数</span></span><br><span class="line">    ::android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(              </span><br><span class="line">            const ::android::sp&lt;::android::IBinder&gt;&amp; obj)               </span><br><span class="line">    &#123;                                                                   </span><br><span class="line">        ::android::sp&lt;IServiceManager&gt; intr;                               </span><br><span class="line">        <span class="keyword">if</span> (obj != NULL) &#123;                                              </span><br><span class="line">            intr = static_cast&lt;IServiceManager*&gt;(                          </span><br><span class="line">                obj-&gt;queryLocalInterface(                               </span><br><span class="line">                        IServiceManager::descriptor).get());               </span><br><span class="line">            <span class="keyword">if</span> (intr == NULL) &#123;   </span><br><span class="line">   <span class="comment">// 新建了一个 BpServiceManager，传入的参数 obj 的值为 BpBinder。           </span></span><br><span class="line">                intr = <span class="keyword">new</span> <span class="title class_">BpServiceManager</span>(obj);                          </span><br><span class="line">            &#125;                                                           </span><br><span class="line">        &#125;                                                               </span><br><span class="line">        <span class="keyword">return</span> intr;                                                    </span><br><span class="line">    &#125;                                                                   </span><br><span class="line">    IServiceManager::IServiceManager() &#123; &#125;                                    </span><br><span class="line">    IServiceManager::~IServiceManager() &#123; &#125;                                   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面代码可知，asInterface 函数就是用 BpBinder 为参数创建了 BpServiceManager，从而推断出interface_cast 函数创建了BpServiceManager，再往上推断，IServiceManager 的 defaultServiceManager 函数返回的就是 BpServiceManager。BpServiceManager有什么作用呢，先从BpServiceManager的构造函数看起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BpServiceManager</span> : <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// impl 的值其实就是 BpBinder，BpServiceManager 的构造函数调用了基类 BpInterface的构造函数。</span></span><br><span class="line">    explicit <span class="title function_">BpServiceManager</span><span class="params">(const sp&lt;IBinder&gt;&amp; impl)</span></span><br><span class="line">        : BpInterface&lt;IServiceManager&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BpInterface 继承了 BpRefBase，BpRefBase 的实现如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/libs/binder/Binder.cpp">Binder.cpp</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BpRefBase::BpRefBase(const sp&lt;IBinder&gt;&amp; o)</span><br><span class="line">    : mRemote(o.get()), mRefs(NULL), mState(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line"><span class="comment">// mRemote 是一个 IBinder* 指针，它最终的指向为 BpBinder，也就是说 BpServiceManager 的 mRemote 指向了 BpBinder。</span></span><br><span class="line"><span class="comment">// 那么 BpServiceManager 的作用也就知道了，就是它实现了 IServiceManager，并且通过 BpBinder来实现通信。</span></span><br><span class="line">    <span class="keyword">if</span> (mRemote) &#123;</span><br><span class="line">        mRemote-&gt;incStrong(<span class="built_in">this</span>);           <span class="comment">// Removed on first IncStrong().</span></span><br><span class="line">        mRefs = mRemote-&gt;createWeak(<span class="built_in">this</span>);  <span class="comment">// Held for our entire lifetime.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IServiceManager家族"><a href="#IServiceManager家族" class="headerlink" title="IServiceManager家族"></a><strong>IServiceManager家族</strong></h4><img data-src="https://imgsw.cn/static/images/ufWhRI.png?imageView2/2/h/600">

<p>1.BpBinder和BBinder都和通信有关，它们都继承自IBinder。<br>2.BpServiceManager派生自IServiceManager，它们都和业务有关。<br>3.BpRefBase包含了mRemote，通过不断的派生，BpServiceManager也同样包含mRemote，它指向了BpBinder，通过BpBinder来实现通信。</p>
<h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a><strong>小节</strong></h3><p>本篇文章我们学到了Binder通信的C&#x2F;S架构，也知道了Native Binder的原理的核心其实就是ServiceManager的原理，为了讲解ServiceManager的原理，我们需要一个框架来举例，那就是MediaPlayer框架。在讲解MediaServer的入口函数时，我们遇到了三个问题，其中前两个问题相关的知识点ProcessState和IServiceManager都讲解到了，下一篇文章会讲解第三个问题，MediaPlayerService是如何注册的。</p>
<h2 id="系统服务的注册过程"><a href="#系统服务的注册过程" class="headerlink" title="系统服务的注册过程"></a><p class="m_more_title_style">系统服务的注册过程</p></h2><p>接下来从调用链角度和进程角度来讲解MediaPlayerService是如何注册的，间接的得出了系统服务是如何注册的<br>。这里分别对这两个角度做了简化，作为应用开发，我们不需要注重太多的过程和细节，只需要了解大概的步骤即可。</p>
<h3 id="从调用链角度说明MediaPlayerService是如何注册的"><a href="#从调用链角度说明MediaPlayerService是如何注册的" class="headerlink" title="从调用链角度说明MediaPlayerService是如何注册的"></a><strong>从调用链角度说明MediaPlayerService是如何注册的</strong></h3><p>先来看MediaServer的入口函数，代码如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/av/media/mediaserver/main_mediaserver.cpp">main_mediaserver.cpp</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc __unused, <span class="type">char</span> **argv __unused)</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">  <span class="comment">//获取ProcessState实例</span></span><br><span class="line">    sp&lt;ProcessState&gt; <span class="title function_">proc</span><span class="params">(ProcessState::self()</span>);</span><br><span class="line">    sp&lt;IServiceManager&gt; <span class="title function_">sm</span><span class="params">(defaultServiceManager()</span>);</span><br><span class="line">    ALOGI(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.get());</span><br><span class="line">    InitializeIcuOrDie();</span><br><span class="line">  <span class="comment">//注册MediaPlayerService</span></span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">    ResourceManagerService::instantiate();</span><br><span class="line">    registerExtensions();</span><br><span class="line">  <span class="comment">//启动Binder线程池</span></span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">  <span class="comment">//当前线程加入到线程池</span></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 MediaPlayerService 的 注册过程。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp">MediaPlayerService.cpp</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MediaPlayerService::instantiate() &#123;    </span><br><span class="line">  <span class="comment">// defaultServiceManager 返回的是 BpServiceManager。</span></span><br><span class="line">  <span class="comment">// 参数是一个字符串和MediaPlayerService，看起来像是Key/Value的形式来完成注册。</span></span><br><span class="line">  defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(<span class="string">&quot;media.player&quot;</span>), <span class="keyword">new</span> <span class="title class_">MediaPlayerService</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 addService 方法。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/libs/binder/IServiceManager.cpp">IServiceManager.cpp</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">virtual status_t <span class="title function_">addService</span><span class="params">(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service,</span></span><br><span class="line"><span class="params">                            bool allowIsolated, <span class="type">int</span> dumpsysPriority)</span> &#123;</span><br><span class="line">    Parcel data, reply; <span class="comment">// data是一个数据包，后面会不断的将数据写入到data中。</span></span><br><span class="line">    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">    data.writeString16(name);  <span class="comment">// name值为&quot;media.player&quot;</span></span><br><span class="line">    data.writeStrongBinder(service);  <span class="comment">//service值为MediaPlayerService</span></span><br><span class="line">    data.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt32(dumpsysPriority);</span><br><span class="line">  <span class="comment">// remote()指的是mRemote，也就是BpBinder。</span></span><br><span class="line">  <span class="comment">// addService函数的作用就是将请求数据打包成data，然后传给BpBinder的transact函数。</span></span><br><span class="line">    <span class="type">status_t</span> <span class="variable">err</span> <span class="operator">=</span> remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">    <span class="type">return</span> <span class="variable">err</span> <span class="operator">=</span>= NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 transact 函数。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/libs/binder/BpBinder.cpp">BpBinder.cpp</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">status_t BpBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">      <span class="comment">//BpBinder将逻辑处理交给IPCThreadState</span></span><br><span class="line">        <span class="type">status_t</span> <span class="variable">status</span> <span class="operator">=</span> IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看IPCThreadState::self()。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/libs/binder/IPCThreadState.cpp">IPCThreadState.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//首次进来gHaveTLS的值为false</span></span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">      <span class="comment">// TLS的全称为Thread local storage，指的是线程本地存储空间，在每个线程中都有TLS，并且线程间不共享。</span></span><br><span class="line">        <span class="type">const</span> <span class="type">pthread_key_t</span> k = gTLS;</span><br><span class="line">      <span class="comment">// 用于获取TLS中的内容并赋值给IPCThreadState指针。</span></span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)<span class="built_in">pthread_getspecific</span>(k);</span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">      <span class="comment">// 会新建一个IPCThreadState，这里可以得知IPCThreadState::self()实际上是为了创建IPCThreadState，</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* IPCThreadState 的构造函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">IPCThreadState::<span class="built_in">IPCThreadState</span>()</span><br><span class="line">    : <span class="built_in">mProcess</span>(ProcessState::<span class="built_in">self</span>()),</span><br><span class="line">      <span class="built_in">mStrictModePolicy</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mLastTransactionBinderFlags</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// pthread_setspecific函数用于设置TLS，将IPCThreadState::self()获得的TLS和自身传进去。</span></span><br><span class="line">    <span class="built_in">pthread_setspecific</span>(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">clearCaller</span>();</span><br><span class="line">   <span class="comment">// IPCThreadState中还包含mIn、一个mOut，其中mIn用来接收来自Binder驱动的数据，mOut用来存储发往Binder驱动的数据，它们默认大小都为256字节。</span></span><br><span class="line">    mIn.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>);</span><br><span class="line">    mOut.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* IPCThreadState 的 transact 函数。</span></span><br><span class="line"><span class="comment">* 调用BpBinder的transact函数实际上就是调用IPCThreadState的transact函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="type">int32_t</span> handle,<span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">// writeTransactionData函数用于传输数据，其中第一个参数BCTRANSACTION代表向Binder驱动发送命令协议，向Binder设备发送的命令协议都以BC开头，而Binder驱动返回的命令协议以BR_开头。  </span></span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;<span class="built_in">setError</span>(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">          <span class="comment">// 调用了 waitForResponse 函数</span></span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//不需要等待reply的分支</span></span><br><span class="line">        err = <span class="built_in">waitForResponse</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="writeTransactionData函数分析"><a href="#writeTransactionData函数分析" class="headerlink" title="writeTransactionData函数分析"></a><strong>writeTransactionData函数分析</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* IPCThreadState 的 writeTransactionData 函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// binder_transaction_data结构体(tr结构体）是向Binder驱动通信的数据结构</span></span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; </span><br><span class="line">  <span class="comment">// 将handle传递给target的handle，用于标识目标，这里的handle的值为0，代表了ServiceManager。</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code; <span class="comment">//code=ADD_SERVICE_TRANSACTION</span></span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 对数据data进行错误检查，如果没有错误就将数据赋值给对应的tr结构体。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>();</span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();</span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="built_in">sizeof</span>(<span class="type">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 最后会将BC_TRANSACTION和tr结构体写入到mOut中。</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);  <span class="comment">//cmd=BC_TRANSACTION</span></span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="waitForResponse函数分析"><a href="#waitForResponse函数分析" class="headerlink" title="waitForResponse函数分析"></a><strong>waitForResponse函数分析</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* IPCThreadState 的 waitForResponse 函数</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="type">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cmd;</span><br><span class="line">    <span class="type">int32_t</span> err;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// talkWithDriver函数的内部通过ioctl与Binder驱动进行通信</span></span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.<span class="built_in">errorCheck</span>();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.<span class="built_in">dataAvail</span>() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="type">uint32_t</span>)mIn.<span class="built_in">readInt32</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Processing waitForResponse Command: &quot;</span></span><br><span class="line">                &lt;&lt; <span class="built_in">getReturnString</span>(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            err = DEAD_OBJECT;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//处理各种命令协议</span></span><br><span class="line">            err = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">finish:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* IPCThreadState 的 talkWithDriver 函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// binder_write_read是和Binder驱动通信的结构体。</span></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"><span class="comment">//mIn是否有可读的数据，接收的数据存储在mIn</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> needRead = mIn.<span class="built_in">dataPosition</span>() &gt;= mIn.<span class="built_in">dataSize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">  <span class="comment">// 将mOut赋值给binder_write_read的相应字段</span></span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();</span><br><span class="line"> <span class="comment">//这时doReceive的值为true</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">      <span class="comment">// 将mIn赋值给binder_write_read的相应字段</span></span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;About to read/write, write size = &quot;</span> &lt;&lt; mOut.<span class="built_in">dataSize</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line"><span class="comment">//ioctl函数和Binder驱动进行通信，这一部分涉及到Kernel Binder的内容了，就不再详细介绍了，只需要知道在Kernel Binder中会记录服务名和handle，用于后续的服务查询。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小节-1"><a href="#小节-1" class="headerlink" title="小节"></a><strong>小节</strong></h4><p>从调用链的角度来看，MediaPlayerService是如何注册的貌似并不复杂，因为这里只是简单的介绍了一个调用链分支，可以简单的总结为以下几个步骤：</p>
<ol>
<li>addService函数将数据打包发送给BpBinder来进行处理。</li>
<li>BpBinder新建一个IPCThreadState对象，并将通信的任务交给IPCThreadState。</li>
<li>IPCThreadState的writeTransactionData函数用于将命令协议和数据写入到mOut中。</li>
<li>IPCThreadState的waitForResponse函数主要做了两件事，一件事是通过ioctl函数操作mOut和mIn来与Binder驱动进行数据交互，另一件事是处理各种命令协议。</li>
</ol>
<h3 id="从进程角度说明MediaPlayerService是如何注册的"><a href="#从进程角度说明MediaPlayerService是如何注册的" class="headerlink" title="从进程角度说明MediaPlayerService是如何注册的"></a><strong>从进程角度说明MediaPlayerService是如何注册的</strong></h3><p>实际上MediaPlayerService的注册还涉及到了进程。</p>
<img data-src="https://imgsw.cn/static/images/Ka0Dx0.png?imageView2/2/h/600">

<p>从图中看出是以C&#x2F;S架构为基础，addService是在MediaPlayerService进行的，它是Client端，用于请求添加系统服务。而Server端则是指的是ServiceManager，用于完成系统服务的添加。<br>Client端和Server端分别运行在两个进程中，通过向Binder来进行通信。更详细点描述，就是两端通过向Binder驱动发送命令协议来完成系统服务的添加。这其中命令协议非常多，过程也比较复杂，这里对命令协议进行了简化，只涉及到了四个命令协议，其中<br>BC_TRANSACTION和BR_TRANSACTION过程是一个完整的事务，BC_REPLY和BR<em>REPLY是一个完整的事务。<br>Client端和Server端向Binder驱动发送命令协议以BC开头，而Binder驱动向Client端和Server端返回的命令协议以BR</em>开头。</p>
<p>步骤如下所示：<br>1.Client端向Binder驱动发送BC_TRANSACTION命令。<br>2.Binder驱动接收到请求后生成BR_TRANSACTION命令，唤醒Server端的线程后将BR_TRANSACTION命令发送给ServiceManager。<br>3.Server端中的服务注册完成后，生成BC_REPLY命令发送给Binder驱动。<br>4.Binder驱动生成BR_REPLY命令，唤醒Client端的线程后将BR_REPLY命令发送个Client端。</p>
<p>通过这些协议命令来驱动并完成系统服务的注册。</p>
<h2 id="ServiceManager的启动过程"><a href="#ServiceManager的启动过程" class="headerlink" title="ServiceManager的启动过程"></a><p class="m_more_title_style">ServiceManager的启动过程</p></h2><p>ServiceManager的启动过程实际上就是分析ServiceManager的入口函数，在入口函数中主要做了三件事。</p>
<h3 id="ServiceManager的入口函数"><a href="#ServiceManager的入口函数" class="headerlink" title="ServiceManager的入口函数"></a><strong>ServiceManager的入口函数</strong></h3><p>ServiceManager是init进程负责启动的，具体是在解析init.rc配置文件时启动的，init进程是在系统启动时启动的，因此ServiceManager亦是如此。<br>rc文件内部由Android初始化语言编写（Android Init Language）编写的脚本，它主要包含五种类型语句：Action、Commands、Services、Options和Import。<br>在Android 7.0中对init.rc文件进行了拆分，每个服务一个rc文件。ServiceManager的启动脚本在servicemanager.rc中。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/7.0.0_r1/xref/frameworks/native/cmds/servicemanager/servicemanager.rc">servicemanager.rc</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service用于通知init进程创建名为servicemanager的进程，这个servicemanager进程执行程序的路径为/system/bin/servicemanager。</span></span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">core</span></span><br><span class="line">   <span class="comment">//关键字user说明servicemanager是以用户system的身份运行的</span></span><br><span class="line">   user system</span><br><span class="line">   group system readproc</span><br><span class="line">   <span class="comment">//critical说明servicemanager是系统中的关键服务，关键服务是不会退出的，如果退出了，系统就会重启，当系统重启时就会启动用onrestart关键字修饰的进程，比如zygote、media、surfaceflinger等等。</span></span><br><span class="line">   critical</span><br><span class="line">   onrestart restart healthd</span><br><span class="line">   onrestart restart zygote</span><br><span class="line">   onrestart restart audioserver</span><br><span class="line">   onrestart restart media</span><br><span class="line">   onrestart restart surfaceflinger</span><br><span class="line">   onrestart restart inputflinger</span><br><span class="line">   onrestart restart drm</span><br><span class="line">   onrestart restart cameraserver</span><br><span class="line">   writepid /dev/cpuset/system-background/tasks</span><br></pre></td></tr></table></figure>

<p>servicemanager的入口函数在service_manager.c中。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/cmds/servicemanager/service_manager.c">service_manager.c</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// binder_state 结构体用来存储binder的三个信息：</span></span><br><span class="line"><span class="comment">//  struct binder_state</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    int fd; //binder设备的文件描述符</span></span><br><span class="line"><span class="comment">//    void *mapped; //binder设备文件映射到进程的地址空间</span></span><br><span class="line"><span class="comment">//    size_t mapsize; //内存映射后，系统分配的地址空间的大小，默认为128KB</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_state</span> *bs;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">selinux_callback</span> cb;</span><br><span class="line">    <span class="type">char</span> *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用binder_open函数用于打开binder设备文件，并申请128k字节大小的内存空间。</span></span><br><span class="line">    bs = <span class="built_in">binder_open</span>(driver, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// 调用binder_become_context_manager函数，将servicemanager注册成为Binder机制的上下文管理者</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">binder_become_context_manager</span>(bs)) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;cannot become context manager (%s)\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getcon</span>(&amp;service_manager_context) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;SELinux: Failed to acquire service_manager context. Aborting.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 调用binder_loop函数，循环等待和处理client端发来的请求。</span></span><br><span class="line">    <span class="built_in">binder_loop</span>(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打开binder设备"><a href="#打开binder设备" class="headerlink" title="打开binder设备"></a><strong>打开binder设备</strong></h4><p>binder_open函数用于打开binder设备文件，并且将它映射到进程的地址空间，如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/cmds/servicemanager/binder.c">binder.c</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_state</span> *<span class="built_in">binder_open</span>(<span class="type">const</span> <span class="type">char</span>* driver, <span class="type">size_t</span> mapsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_state</span> *bs;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_version</span> vers;</span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*bs));</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 打开binder设备文件</span></span><br><span class="line"><span class="comment">// open函数，它会调用Kernel Binder部分的binder_open函数，这部分源码位于内核源码中，这里展示的代码版本为goldfish3.4。</span></span><br><span class="line">    bs-&gt;fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;binder: cannot open %s (%s)\n&quot;</span>,</span><br><span class="line">                driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ioctl函数用于获取Binder的版本，如果获取不到或者内核空间和用户空间的binder不是同一个版本就会直接goto到fail_open标签，释放binder的内存空间。</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_VERSION, &amp;vers) == <span class="number">-1</span>) ||</span><br><span class="line">        (vers.protocol_version != BINDER_CURRENT_PROTOCOL_VERSION)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,</span><br><span class="line">                <span class="string">&quot;binder: kernel driver version (%d) differs from user space version (%d)\n&quot;</span>,</span><br><span class="line">                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line"><span class="comment">// 调用mmap函数进行内存映射，通俗来讲就是将binder设备文件映射到进程的地址空间，地址空间的大小为mapsize，也就是128K。映射完毕后会将地址空间的起始地址和大小保存在binder_state结构体中的mapped和mapsize变量中。</span></span><br><span class="line">    bs-&gt;mapped = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;binder: cannot map device (%s)\n&quot;</span>,</span><br><span class="line">                <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    <span class="built_in">close</span>(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    <span class="built_in">free</span>(bs);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用户态和内核态</strong><br>临时插入一个知识点:用户态和内核态<br>Intel的X86架构的CPU提供了0到3四个特权级，数字越小，权限越高，Linux操作系统中主要采用了0和3两个特权级，分别对应的就是内核态与用户态。用户态的特权级别低，因此进程在用户态下不经过系统调用是无法主动访问到内核空间中的数据的，这样用户无法随意的进入所有进程共享的内核空间，起到了保护的作用。下面来介绍下什么是用户态和内核态。<br>当一个进程在执行用户自己的代码时处于用户态，比如open函数，它运行在用户空间，当前的进程处于用户态。<br>当一个进程因为系统调用进入内核代码中执行时就处于内核态，比如open函数通过系统调用（__open()函数），查找到了open函数在Kernel Binder对应的函数为binder_open，这时binder_open运行在内核空间，当前的进程由用户态切换到内核态。</p>
<p><strong>kernel&#x2F;goldfish&#x2F;drivers&#x2F;staging&#x2F;android&#x2F;binder.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">  <span class="comment">//binder_proc结构体代表binder进程，用于管理binder的各种信息。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc;</span><br><span class="line">  <span class="built_in">binder_debug</span>(BINDER_DEBUG_OPEN_CLOSE, <span class="string">&quot;binder_open: %d:%d\n&quot;</span>,</span><br><span class="line">         current-&gt;group_leader-&gt;pid, current-&gt;pid);</span><br><span class="line">  <span class="comment">//为binder_proc分配内存空间。</span></span><br><span class="line">  proc = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">  <span class="built_in">get_task_struct</span>(current);</span><br><span class="line">  proc-&gt;tsk = current;</span><br><span class="line">  <span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;todo);</span><br><span class="line">  <span class="built_in">init_waitqueue_head</span>(&amp;proc-&gt;wait);</span><br><span class="line">  proc-&gt;default_priority = <span class="built_in">task_nice</span>(current);</span><br><span class="line">    <span class="comment">//binder同步锁</span></span><br><span class="line">  <span class="built_in">binder_lock</span>(__func__);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">binder_stats_created</span>(BINDER_STAT_PROC);</span><br><span class="line">  <span class="built_in">hlist_add_head</span>(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">  proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">  <span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;delivered_death);</span><br><span class="line">  <span class="comment">// 将binder_proc赋值给file指针的private_data变量</span></span><br><span class="line">  filp-&gt;private_data = proc;</span><br><span class="line">    <span class="comment">//binder同步锁释放</span></span><br><span class="line">  <span class="built_in">binder_unlock</span>(__func__);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册成为Binder机制的上下文管理者"><a href="#注册成为Binder机制的上下文管理者" class="headerlink" title="注册成为Binder机制的上下文管理者"></a><strong>注册成为Binder机制的上下文管理者</strong></h4><p>binder_become_context_manager函数用于将servicemanager注册成为Binder机制的上下文管理者，这个管理者在整个系统只有一个，代码如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/cmds/servicemanager/binder.c">binder.c</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_become_context_manager</span><span class="params">(<span class="keyword">struct</span> binder_state *bs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ioctl函数会调用Binder驱动的binder_ioctl函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder_ioctl函数代码比较多，这里截取BINDER_SET_CONTEXT_MGR的处理部分，代码如下所示。<br><strong>kernel&#x2F;goldfish&#x2F;drivers&#x2F;staging&#x2F;android&#x2F;binder.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="comment">// 将file指针中的private_data变量赋值给binder_proc，这个private_data变量在binder_open函数中讲过，是一个binder_proc结构体。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc = filp-&gt;private_data; </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">binder_thread</span> *thread;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">  <span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line">  <span class="built_in">trace_binder_ioctl</span>(cmd, arg);</span><br><span class="line"></span><br><span class="line">  ret = <span class="built_in">wait_event_interruptible</span>(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret)</span><br><span class="line">    <span class="keyword">goto</span> err_unlocked;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">binder_lock</span>(__func__);</span><br><span class="line">  <span class="comment">// binder_get_thread函数用于获取binder_thread，binder_thread结构体指的是binder线程，binder_get_thread函数内部会从传入的参数binder_proc中查找binder_thread，如果查询到直接返回，如果查询不到会创建一个新的binder_thread并返回。</span></span><br><span class="line">  thread = <span class="built_in">binder_get_thread</span>(proc);</span><br><span class="line">  <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ret = -ENOMEM;</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">      <span class="comment">// 全局变量binder_context_mgr_node代表的是Binder机制的上下文管理者对应的一个Binder对象，如果它不为NULL，说明此前自身已经被注册为Binder的上下文管理者了，Binder的上下文管理者是不能重复注册的，因此会goto到err标签。</span></span><br><span class="line">    <span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;binder: BINDER_SET_CONTEXT_MGR already set\n&quot;</span>);</span><br><span class="line">      ret = -EBUSY;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">security_binder_set_context_mgr</span>(proc-&gt;tsk);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">      <span class="comment">// 全局变量binder_context_mgr_uid代表注册了Binder机制上下文管理者的进程的有效用户ID，如果它的值不为-1，说明此前已经有进程注册Binder的上下文管理者了。</span></span><br><span class="line">    <span class="keyword">if</span> (binder_context_mgr_uid != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断当前进程的有效用户ID是否等于binder_context_mgr_uid，不等于就goto到err标签。</span></span><br><span class="line">      <span class="keyword">if</span> (binder_context_mgr_uid != current-&gt;cred-&gt;euid) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;binder: BINDER_SET_&quot;</span></span><br><span class="line">               <span class="string">&quot;CONTEXT_MGR bad uid %d != %d\n&quot;</span>,</span><br><span class="line">               current-&gt;cred-&gt;euid,</span><br><span class="line">               binder_context_mgr_uid);</span><br><span class="line">        ret = -EPERM;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// 如果不满足判断条件，说明此前没有进程注册Binder机制的上下文管理者。</span></span><br><span class="line">      <span class="comment">// 将当前进程的有效用户ID赋值给全局变量binder_context_mgr_uid。</span></span><br><span class="line">      binder_context_mgr_uid = current-&gt;cred-&gt;euid;</span><br><span class="line">      <span class="comment">// 调用binder_new_node函数创建一个Binder对象并赋值给全局变量binder_context_mgr_node。</span></span><br><span class="line">     	binder_context_mgr_node = <span class="built_in">binder_new_node</span>(proc, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">if</span> (binder_context_mgr_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      	ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    	&#125;</span><br><span class="line">    	binder_context_mgr_node-&gt;local_weak_refs++;</span><br><span class="line">    	binder_context_mgr_node-&gt;local_strong_refs++;</span><br><span class="line">    	binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">    	binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">break</span>;</span><br><span class="line">   ...</span><br><span class="line">err_unlocked:</span><br><span class="line">  <span class="built_in">trace_binder_ioctl_done</span>(ret);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环等待和处理client端发来的请求"><a href="#循环等待和处理client端发来的请求" class="headerlink" title="循环等待和处理client端发来的请求"></a><strong>循环等待和处理client端发来的请求</strong></h4><p>servicemanager成功注册成为Binder机制的上下文管理者后，servicemanager就是Binder机制的“总管”了，它需要在系统运行期间处理client端的请求，由于client端的请求不确定何时发送，因此需要通过无限循环来实现，实现这一需求的函数就是binder_loop。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/cmds/servicemanager/binder.c">binder.c</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binder_loop</span><span class="params">(<span class="keyword">struct</span> binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_write_read</span> bwr;</span><br><span class="line">    <span class="type">uint32_t</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">  <span class="comment">// 将BC_ENTER_LOOPER指令通过binder_write函数写入到Binder驱动中，这样当前线程（ServiceManager的主线程）就成为了一个Binder线程，这样就可以处理进程间的请求了。</span></span><br><span class="line">    <span class="built_in">binder_write</span>(bs, readbuf, <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="built_in">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>) readbuf;</span><br><span class="line"><span class="comment">// 在无限循环中不断的调用ioctl函数，它不断的使用BINDER_WRITE_READ指令查询Binder驱动中是否有新的请求，</span></span><br><span class="line">        res = <span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: ioctl failed (%s)\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 如果有新的请求就交给binder_parse函数处理。如果没有，当前线程就会在Binder驱动中睡眠，等待新的进程间请求。</span></span><br><span class="line">        res = <span class="built_in">binder_parse</span>(bs, <span class="number">0</span>, (<span class="type">uintptr_t</span>) readbuf, bwr.read_consumed, func);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: unexpected reply?!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;binder_loop: io error %d %s\n&quot;</span>, res, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于binder_write函数的调用链中涉及到了内核空间和用户空间的交互，因此这里着重讲解下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_write</span><span class="params">(<span class="keyword">struct</span> binder_state *bs, <span class="type">void</span> *data, <span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 定义binder_write_read结构体</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_write_read</span> bwr;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"><span class="comment">// 对bwr进行赋值</span></span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// data的值为BC_ENTER_LOOPER</span></span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>) data;</span><br><span class="line">    bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ioctl函数将会bwr中的数据发送给binder驱动。</span></span><br><span class="line">    res = <span class="built_in">ioctl</span>(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;binder_write: ioctl failed (%s)\n&quot;</span>,</span><br><span class="line">                <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ioctl函数在Kernel Binder中对应的函数为binder_ioctl，此前分析过这个函数，这里截取BINDER_WRITE_READ命令处理部分。</p>
<p><strong>kernel&#x2F;goldfish&#x2F;drivers&#x2F;staging&#x2F;android&#x2F;binder.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ...</span><br><span class="line">    <span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">  <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">binder_write_read</span> bwr;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) &#123;</span><br><span class="line">      ret = -EINVAL;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy_from_user函数，在这里，它用于将把用户空间数据ubuf拷贝出来保存到内核数据bwr（binder_write_read结构体）中。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;bwr, ubuf, <span class="built_in">sizeof</span>(bwr))) &#123;</span><br><span class="line">      ret = -EFAULT;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">binder_debug</span>(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">           <span class="string">&quot;binder: %d:%d write %ld at %08lx, read %ld at %08lx\n&quot;</span>,</span><br><span class="line">           proc-&gt;pid, thread-&gt;pid, bwr.write_size, bwr.write_buffer,</span><br><span class="line">           bwr.read_size, bwr.read_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// bwr的输入缓存区有数据时，会调用binder_thread_write函数来处理BC_ENTER_LOOPER协议，其内部会将目标线程的状态设置为BINDER_LOOPER_STATE_ENTERED，这样目标线程就是一个Binder线程。</span></span><br><span class="line">      ret = <span class="built_in">binder_thread_write</span>(proc, thread, (<span class="type">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">      <span class="built_in">trace_binder_write_done</span>(ret);</span><br><span class="line">      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr)))</span><br><span class="line">          ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      ...</span><br><span class="line">    <span class="built_in">binder_debug</span>(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">           <span class="string">&quot;binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n&quot;</span>,</span><br><span class="line">           proc-&gt;pid, thread-&gt;pid, bwr.write_consumed, bwr.write_size,</span><br><span class="line">           bwr.read_consumed, bwr.read_size);</span><br><span class="line">    <span class="comment">//通过copy_to_user函数将内核空间数据bwr拷贝到用户空间。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr))) &#123;</span><br><span class="line">      ret = -EFAULT;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="系统服务的获取过程"><a href="#系统服务的获取过程" class="headerlink" title="系统服务的获取过程"></a><p class="m_more_title_style">系统服务的获取过程</p></h2><p>此前以MediaPlayerService为例，讲解了系统服务是如何注册的（addService），既然有注册那肯定也要有获取，仍旧以MediaPlayerService为例，来讲解系统服务的获取过程（getService）。会分为两个部分进行讲解，分别是客户端MediaPlayerService请求获取服务和服务端ServiceManager处理请求。</p>
<h3 id="客户端MediaPlayerService请求获取服务"><a href="#客户端MediaPlayerService请求获取服务" class="headerlink" title="客户端MediaPlayerService请求获取服务"></a><strong>客户端MediaPlayerService请求获取服务</strong></h3><p>要想获取MediaPlayerService，需要先调用getMediaPlayerService函数，如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/av/media/libmedia/IMediaDeathNotifier.cpp">IMediaDeathNotifier.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IMediaDeathNotifier::<span class="built_in">getMediaPlayerService</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;getMediaPlayerService&quot;</span>);</span><br><span class="line">    Mutex::Autolock _l(sServiceLock);</span><br><span class="line">    <span class="keyword">if</span> (sMediaPlayerService == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// defaultServiceManager返回的是BpServiceManager</span></span><br><span class="line">        sp&lt;IServiceManager&gt; sm = <span class="built_in">defaultServiceManager</span>();</span><br><span class="line">        sp&lt;IBinder&gt; binder;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="comment">// 获取名为”media.player”的系统服务（MediaPlayerService），返回的值为BpBinder。</span></span><br><span class="line">            binder = sm-&gt;<span class="built_in">getService</span>(<span class="built_in">String16</span>(<span class="string">&quot;media.player&quot;</span>));</span><br><span class="line">          <span class="comment">// 由于这个时候MediaPlayerService可能还没有向ServiceManager注册，那么就不能满足条件。</span></span><br><span class="line">            <span class="keyword">if</span> (binder != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Media player service not published, waiting...&quot;</span>);</span><br><span class="line">          <span class="comment">// 休眠0.5s后继续调用getService函数，直到获取服务对应的为止。</span></span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">500000</span>); <span class="comment">// 0.5 s</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sDeathNotifier == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sDeathNotifier = <span class="keyword">new</span> <span class="built_in">DeathNotifier</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        binder-&gt;<span class="built_in">linkToDeath</span>(sDeathNotifier);</span><br><span class="line">      <span class="comment">// interface_cast函数用于将BpBinder转换成BpMediaPlayerService，其原理就是通过BpBinder的handle来找到对应的服务，即BpMediaPlayerService。</span></span><br><span class="line">        sMediaPlayerService = <span class="built_in">interface_cast</span>&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ALOGE_IF</span>(sMediaPlayerService == <span class="number">0</span>, <span class="string">&quot;no media player service!?&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取服务是重点，BpServiceManager的getService函数如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/libs/binder/IServiceManager.cpp">IServiceManager.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BpServiceManager</span> : <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">getService</span><span class="params">(<span class="type">const</span> String16&amp; name)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">uptimeMillis</span>() &lt; timeout) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">if</span> (isVendorService) &#123;</span><br><span class="line">                <span class="built_in">ALOGI</span>(<span class="string">&quot;Waiting for vendor service %s...&quot;</span>, <span class="built_in">String8</span>(name).<span class="built_in">string</span>());</span><br><span class="line">                <span class="function">CallStack <span class="title">stack</span><span class="params">(LOG_TAG)</span></span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n%<span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGI</span>(<span class="string">&quot;Waiting for service %s...&quot;</span>, <span class="built_in">String8</span>(name).<span class="built_in">string</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1000</span>*sleepTime);</span><br><span class="line"></span><br><span class="line">            sp&lt;IBinder&gt; svc = <span class="built_in">checkService</span>(name);</span><br><span class="line">            <span class="keyword">if</span> (svc != <span class="literal">NULL</span>) <span class="keyword">return</span> svc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Service %s didn&#x27;t start. Returning NULL&quot;</span>, <span class="built_in">String8</span>(name).<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>getService函数中主要做的事就是循环的查询服务是否存在，如果不存在就继续查询，查询服务用到了checkService函数，代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BpServiceManager</span> : <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">checkService</span><span class="params">( <span class="type">const</span> String16&amp; name)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">  <span class="comment">// data，此前它出现在BpServiceManager的addService函数中，data是一个数据包，后面会不断的将数据写入到data中。</span></span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.<span class="built_in">writeInterfaceToken</span>(IServiceManager::<span class="built_in">getInterfaceDescriptor</span>());</span><br><span class="line">  <span class="comment">// 将字符串”media.player”写入到data中。</span></span><br><span class="line">        data.<span class="built_in">writeString16</span>(name);</span><br><span class="line">  <span class="comment">// remote()指的是mRemote，也就是BpBinder。</span></span><br><span class="line">        <span class="built_in">remote</span>()-&gt;<span class="built_in">transact</span>(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        <span class="keyword">return</span> reply.<span class="built_in">readStrongBinder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BpBinder的transact函数如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/libs/binder/BpBinder.cpp">BpBinder.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BpBinder 将逻辑处理交给 IPCThreadState，后面的调用链在此前的系统服务的注册过程中有讲，最后会调用到talkWithDriver函数，其内部通过ioctl与Binder驱动进行通信。</p>
<p>当前分析的是客户端进程的流程，当MediaPlayerService向Binder驱动发送BC_TRANSACTION命令后，Binder驱动会向ServiceManager发送BR_TRANSACTION命令，接下来查看服务端ServiceManager是如何处理获取服务这一请求的。</p>
<h3 id="服务端ServiceManager处理请求"><a href="#服务端ServiceManager处理请求" class="headerlink" title="服务端ServiceManager处理请求"></a><strong>服务端ServiceManager处理请求</strong></h3><p>说到服务端ServiceManager处理请求，不得不说到ServiceManager的启动过程，在 servicemanager 的入口 man 函数中主要做了三件事，其中最后一件事就是调用binder_loop函数，这里需要注意，它的第二个参数为svcmgr_handler。</p>
<p>binder_loop函数在无限循环中不断的调用ioctl函数，它不断的使用BINDER_WRITE_READ指令查询Binder驱动中是否有新的请求，如果有就交给binder_parse函数处理。如果没有，当前线程就会在Binder驱动中睡眠，等待新的进程间通信请求。binder_parse函数如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/cmds/servicemanager/binder.c">binder.c</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_parse</span><span class="params">(<span class="keyword">struct</span> binder_state *bs, <span class="keyword">struct</span> binder_io *bio,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">uintptr_t</span> ptr, <span class="type">size_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uintptr_t</span> end = ptr + (<span class="type">uintptr_t</span>) size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> cmd = *(<span class="type">uint32_t</span> *) ptr;</span><br><span class="line">        ptr += <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRACE</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;%s:\n&quot;</span>, <span class="built_in">cmd_name</span>(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line"> <span class="comment">// 这里截取了BR_TRANSACTION命令的处理部分。</span></span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">binder_transaction_data</span> *txn = (<span class="keyword">struct</span> binder_transaction_data *) ptr;</span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) &lt; <span class="built_in">sizeof</span>(*txn)) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;parse: txn too small!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">binder_dump_txn</span>(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="type">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">binder_io</span> msg;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">binder_io</span> reply;</span><br><span class="line">                <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">bio_init</span>(&amp;reply, rdata, <span class="built_in">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                <span class="built_in">bio_init_from_txn</span>(&amp;msg, txn);</span><br><span class="line">              <span class="comment">// func通过一路传递指向的是 svcmgr_handler</span></span><br><span class="line">                res = <span class="built_in">func</span>(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                <span class="keyword">if</span> (txn-&gt;flags &amp; TF_ONE_WAY) &#123;</span><br><span class="line">                    <span class="built_in">binder_free_buffer</span>(bs, txn-&gt;data.ptr.buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">binder_send_reply</span>(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="built_in">sizeof</span>(*txn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 svcmgr_handler 。 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/native/cmds/servicemanager/service_manager.c">service_manager.c</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">svcmgr_handler</span><span class="params">(<span class="keyword">struct</span> binder_state *bs,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">struct</span> binder_transaction_data *txn,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">struct</span> binder_io *msg,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">struct</span> binder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s = <span class="built_in">bio_get_string16</span>(msg, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        handle = <span class="built_in">do_find_service</span>(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">        <span class="keyword">if</span> (!handle)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">bio_put_ref</span>(reply, handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;unknown code %d\n&quot;</span>, txn-&gt;code);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bio_put_uint32</span>(reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当要获取服务时，会调用do_find_service函数，代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">do_find_service</span><span class="params">(<span class="type">const</span> <span class="type">uint16_t</span> *s, <span class="type">size_t</span> len, <span class="type">uid_t</span> uid, <span class="type">pid_t</span> spid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// find_svc函数用于查询服务，返回的svcinfo是一个结构体，其内部包含了服务的handle值。</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">svcinfo</span> *si = <span class="built_in">find_svc</span>(s, len);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si || !si-&gt;handle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;allow_isolated) &#123;</span><br><span class="line">        <span class="type">uid_t</span> appid = uid % AID_USER;</span><br><span class="line">        <span class="keyword">if</span> (appid &gt;= AID_ISOLATED_START &amp;&amp; appid &lt;= AID_ISOLATED_END) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">svc_can_find</span>(s, len, spid, uid)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 最终会返回服务的handle值。</span></span><br><span class="line">    <span class="keyword">return</span> si-&gt;handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看find_svc函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">svcinfo</span> *<span class="built_in">find_svc</span>(<span class="type">const</span> <span class="type">uint16_t</span> *s16, <span class="type">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">svcinfo</span> *si;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (si = svclist; si; si = si-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((len == si-&gt;len) &amp;&amp;</span><br><span class="line">            !<span class="built_in">memcmp</span>(s16, si-&gt;name, len * <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统服务的注册流程中，在Kernel Binder中会调用do_add_service函数，其内部会将包含服务名和handle值的svcinfo保存到svclist列表中。同样的，在获取服务的流程中，find_svc函数中会遍历svclist列表，根据服务名查找对应服务是否已经注册，如果已经注册就会返回对应的svcinfo，如果没有注册就返回NULL。</p>
<h2 id="Java-Binder的初始化"><a href="#Java-Binder的初始化" class="headerlink" title="Java Binder的初始化"></a><p class="m_more_title_style">Java Binder的初始化</p></h2><p>此前都在介绍Native Binder和Kernel Binder的内容，它们的架构简单总结为下图。</p>
<img data-src="https://imgsw.cn/static/images/MgRMbF.png?imageView2/2/h/600">

<p>在ServiceManager中的Binder机制中，知道BpBinder是Client端与Server交互的代理类，而BBinder则代表了Server端，那么上图就可以改为：</p>
<img data-src="https://imgsw.cn/static/images/MgWuRI.png?imageView2/2/h/600">

<p>从上图可以看到，Native Binder实际是基于C&#x2F;S架构，Bpinder是Client端，BBinder是Server端，在ServiceManager的启动过程中，得知Native Binder通过ioctl函数和Binder驱动进行数据交互。</p>
<p>Java Binder是需要借助Native Binder来进行工作的，因此Java Binder在设计上也是一个C&#x2F;S架构，可以说Java Binder是Native Binder的一个镜像，接下来看 Java Binder 是如何初始化的，即Java Binder的JNI注册。</p>
<h3 id="Java-Binder的JNI注册"><a href="#Java-Binder的JNI注册" class="headerlink" title="Java Binder的JNI注册"></a><strong>Java Binder的JNI注册</strong></h3><p>Java Binder要想和Native Binder进行通信，需要通过JNI，JNI的注册是在Zygote进程启动过程中注册的，代码如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/AndroidRuntime.cpp">AndroidRuntime.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* className, <span class="type">const</span> Vector&lt;String8&gt;&amp; options, <span class="type">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.<span class="built_in">Init</span>(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">  <span class="comment">// 启动Java虚拟机</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">onVmCreated</span>(env);</span><br><span class="line">  <span class="comment">// startReg 函数用于完成虚拟机的JNI注册</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">startReg</span>(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startReg函数如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*static*/</span> <span class="function"><span class="type">int</span> <span class="title">AndroidRuntime::startReg</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;RegisterAndroidNatives&quot;</span>);</span><br><span class="line">    <span class="built_in">androidSetCreateThreadFunc</span>((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;--- registering native functions ---\n&quot;</span>);</span><br><span class="line">    env-&gt;<span class="built_in">PushLocalFrame</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">register_jni_procs</span>(gRegJNI, <span class="built_in">NELEM</span>(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;<span class="built_in">PopLocalFrame</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;<span class="built_in">PopLocalFrame</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>register_jni_procs函数的作用就是循环调用gRegJNI数组的成员所对应的方法，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="type">const</span> RegJNIRec array[], <span class="type">size_t</span> count, JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i].<span class="built_in">mProc</span>(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">            <span class="built_in">ALOGD</span>(<span class="string">&quot;----------!!! %s failed to load\n&quot;</span>, array[i].mName);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gRegJNI数组中有100多个成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    <span class="built_in">REG_JNI</span>(register_com_android_internal_os_RuntimeInit),</span><br><span class="line">    <span class="built_in">REG_JNI</span>(register_com_android_internal_os_ZygoteInit_nativeZygoteInit),</span><br><span class="line">    <span class="built_in">REG_JNI</span>(register_android_os_SystemClock),</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// register_android_os_Binder 函数负责Java Binder和Native Binder通信。</span></span><br><span class="line">    <span class="built_in">REG_JNI</span>(register_android_os_Binder),</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中REG_JNI是一个宏定义，实际上就是调用参数名所对应的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REG_JNI(name)      &#123; name &#125;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RegJNIRec</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> (*mProc)(JNIEnv*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>查看 register_android_os_Binder 函数，它做了如下三件事。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/android_util_Binder.cpp">android_util_Binder.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//注册Binder类</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int_register_android_os_Binder</span>(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//注册BinderInternal类        </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int_register_android_os_BinderInternal</span>(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//注册BinderProxy类          </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int_register_android_os_BinderProxy</span>(env) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img data-src="https://imgsw.cn/static/images/MTmhzd.png?imageView2/2/h/600">

<p>它们是Java Binder关联类的一小部分，它们的关系如下。</p>
<ul>
<li>IBinder接口中定义了很多整型的变量，其中定义一个叫做<code>FLAG_ONEWAY</code>的整形变量。客户端发起调用时，客户端一般会阻塞，直到服务端返回结果。设置<code>FLAG_ONEWAY</code>后，客户端只需要把请求发送到服务端就可以立即返回，而不需要等待服务端的结果，这是一种非阻塞方式。</li>
<li>Binder和BinderProxy实现了IBinder接口，Binder是服务端的代表，而BinderProxy是客户端的代表。</li>
<li>BinderInternal只是在Binder框架中被使用，其内部类GcWatcher用于处理和Binder的垃圾回收。</li>
<li>Parcel是一个数据包装器，它可以在进程间进行传递，Parcel既可以传递基本数据类型也可以传递Binder对象，Binder通信就是通过Parcel来进行客户端与服务端数据交互。Parcel的实现既有Java部分，也有Native部分，具体实现在Native部分中。</li>
</ul>
<p>下面分别对Binder、BinderInternal这两个类的注册进行分析。</p>
<h3 id="Binder类的注册"><a href="#Binder类的注册" class="headerlink" title="Binder类的注册"></a><strong>Binder类的注册</strong></h3><p>调用int_register_android_os_Binder函数来完成Binder类的注册，代码如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/android_util_Binder.cpp">android_util_Binder.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod gBinderMethods[] = &#123;</span><br><span class="line">     <span class="comment">/* name, signature, funcPtr */</span></span><br><span class="line">    &#123; <span class="string">&quot;getCallingPid&quot;</span>, <span class="string">&quot;()I&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getCallingPid &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;getCallingUid&quot;</span>, <span class="string">&quot;()I&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getCallingUid &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;clearCallingIdentity&quot;</span>, <span class="string">&quot;()J&quot;</span>, (<span class="type">void</span>*)android_os_Binder_clearCallingIdentity &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;restoreCallingIdentity&quot;</span>, <span class="string">&quot;(J)V&quot;</span>, (<span class="type">void</span>*)android_os_Binder_restoreCallingIdentity &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;setThreadStrictModePolicy&quot;</span>, <span class="string">&quot;(I)V&quot;</span>, (<span class="type">void</span>*)android_os_Binder_setThreadStrictModePolicy &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;getThreadStrictModePolicy&quot;</span>, <span class="string">&quot;()I&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getThreadStrictModePolicy &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;flushPendingCommands&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="type">void</span>*)android_os_Binder_flushPendingCommands &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;getNativeBBinderHolder&quot;</span>, <span class="string">&quot;()J&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getNativeBBinderHolder &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;getNativeFinalizer&quot;</span>, <span class="string">&quot;()J&quot;</span>, (<span class="type">void</span>*)android_os_Binder_getNativeFinalizer &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;blockUntilThreadAvailable&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="type">void</span>*)android_os_Binder_blockUntilThreadAvailable &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// kBinderPathName的值为”android/os/Binder”，这是Binder在Java Binder中的全路径名。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> kBinderPathName = <span class="string">&quot;android/os/Binder&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">int_register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 根据路径名获取Binder的Class对象，并赋值给jclass类型的变量clazz，clazz是Java层Binder在JNI层的代表。</span></span><br><span class="line">    jclass clazz = <span class="built_in">FindClassOrDie</span>(env, kBinderPathName);</span><br><span class="line"><span class="comment">// 通过MakeGlobalRefOrDie函数将本地引用clazz转变为全局引用并赋值给gBinderOffsets.mClass。</span></span><br><span class="line">    gBinderOffsets.mClass = <span class="built_in">MakeGlobalRefOrDie</span>(env, clazz);</span><br><span class="line">  <span class="comment">// 用于找到Java层的Binder的成员方法execTransact并赋值给gBinderOffsets.mExecTransact。</span></span><br><span class="line">    gBinderOffsets.mExecTransact = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;execTransact&quot;</span>, <span class="string">&quot;(IJJI)Z&quot;</span>);</span><br><span class="line">  <span class="comment">// 用于找到Java层的Binder的成员变量mObject并赋值给gBinderOffsets.mObject。</span></span><br><span class="line">    gBinderOffsets.mObject = <span class="built_in">GetFieldIDOrDie</span>(env, clazz, <span class="string">&quot;mObject&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line"><span class="comment">// 通过RegisterMethodsOrDie函数注册gBinderMethods中定义的函数，其中gBinderMethods是JNINativeMethod类型的数组，里面存储的是Binder的Native方法（Java层）与JNI层函数的对应关系。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(</span><br><span class="line">        env, kBinderPathName,</span><br><span class="line">        gBinderMethods, <span class="built_in">NELEM</span>(gBinderMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gBinderMethods的定义如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">bindernative_offsets_t</span></span><br><span class="line">&#123;</span><br><span class="line">    jclass mClass;</span><br><span class="line">    jmethodID mExecTransact;</span><br><span class="line">    jfieldID mObject;</span><br><span class="line"></span><br><span class="line">&#125; gBinderOffsets;</span><br></pre></td></tr></table></figure>

<p>使用gBinderMethods来保存变量和方法有两个原因：<br>1.为了效率考虑，如果每次调用相关的方法时都需要查询方法和变量，显然效率比较低。<br>2.这些成员变量和方法都是本地引用，在int int_register_android_os_Binder函数返回时，这些本地引用会被自动释放，因此用gBinderOffsets来保存，以便于后续使用。</p>
<h3 id="BinderInternal类的注册"><a href="#BinderInternal类的注册" class="headerlink" title="BinderInternal类的注册"></a><strong>BinderInternal类的注册</strong></h3><p>调用int_register_android_os_BinderInternal函数来完成BinderInternal类的注册，代码如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/android_util_Binder.cpp">android_util_Binder.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> kBinderInternalPathName = <span class="string">&quot;com/android/internal/os/BinderInternal&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">int_register_android_os_BinderInternal</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jclass clazz = <span class="built_in">FindClassOrDie</span>(env, kBinderInternalPathName);</span><br><span class="line"></span><br><span class="line">    gBinderInternalOffsets.mClass = <span class="built_in">MakeGlobalRefOrDie</span>(env, clazz);</span><br><span class="line">    gBinderInternalOffsets.mForceGc = <span class="built_in">GetStaticMethodIDOrDie</span>(env, clazz, <span class="string">&quot;forceBinderGc&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    gBinderInternalOffsets.mProxyLimitCallback = <span class="built_in">GetStaticMethodIDOrDie</span>(env, clazz, <span class="string">&quot;binderProxyLimitCallbackFromNative&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    jclass SparseIntArrayClass = <span class="built_in">FindClassOrDie</span>(env, <span class="string">&quot;android/util/SparseIntArray&quot;</span>);</span><br><span class="line">    gSparseIntArrayOffsets.classObject = <span class="built_in">MakeGlobalRefOrDie</span>(env, SparseIntArrayClass);</span><br><span class="line">    gSparseIntArrayOffsets.constructor = <span class="built_in">GetMethodIDOrDie</span>(env, gSparseIntArrayOffsets.classObject,</span><br><span class="line">                                                           <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    gSparseIntArrayOffsets.put = <span class="built_in">GetMethodIDOrDie</span>(env, gSparseIntArrayOffsets.classObject, <span class="string">&quot;put&quot;</span>,</span><br><span class="line">                                                   <span class="string">&quot;(II)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    BpBinder::<span class="built_in">setLimitCallback</span>(android_os_BinderInternal_proxyLimitcallback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(</span><br><span class="line">        env, kBinderInternalPathName,</span><br><span class="line">        gBinderInternalMethods, <span class="built_in">NELEM</span>(gBinderInternalMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和int_register_android_os_Binder函数的实现类似，主要做了三件事：<br>1.获取BinderInternal在JNI层的代表clazz。<br>2.将BinderInternal类中有用的成员变量和方法存储到gBinderInternalOffsets中。<br>3.注册BinderInternal类的Native方法对应的JNI函数。</p>
<h3 id="BinderProxy类的注册"><a href="#BinderProxy类的注册" class="headerlink" title="BinderProxy类的注册"></a><strong>BinderProxy类的注册</strong></h3><p>它和Binder、BinderInternal的注册过程差不多。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">int_register_android_os_BinderProxy</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jclass clazz = <span class="built_in">FindClassOrDie</span>(env, <span class="string">&quot;java/lang/Error&quot;</span>);</span><br><span class="line">    gErrorOffsets.mClass = <span class="built_in">MakeGlobalRefOrDie</span>(env, clazz);</span><br><span class="line"></span><br><span class="line">    clazz = <span class="built_in">FindClassOrDie</span>(env, kBinderProxyPathName);</span><br><span class="line">    gBinderProxyOffsets.mClass = <span class="built_in">MakeGlobalRefOrDie</span>(env, clazz);</span><br><span class="line">    gBinderProxyOffsets.mGetInstance = <span class="built_in">GetStaticMethodIDOrDie</span>(env, clazz, <span class="string">&quot;getInstance&quot;</span>,</span><br><span class="line">            <span class="string">&quot;(JJ)Landroid/os/BinderProxy;&quot;</span>);</span><br><span class="line">    gBinderProxyOffsets.mSendDeathNotice = <span class="built_in">GetStaticMethodIDOrDie</span>(env, clazz, <span class="string">&quot;sendDeathNotice&quot;</span>,</span><br><span class="line">            <span class="string">&quot;(Landroid/os/IBinder$DeathRecipient;)V&quot;</span>);</span><br><span class="line">    gBinderProxyOffsets.mDumpProxyDebugInfo = <span class="built_in">GetStaticMethodIDOrDie</span>(env, clazz, <span class="string">&quot;dumpProxyDebugInfo&quot;</span>,</span><br><span class="line">            <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    gBinderProxyOffsets.mNativeData = <span class="built_in">GetFieldIDOrDie</span>(env, clazz, <span class="string">&quot;mNativeData&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clazz = <span class="built_in">FindClassOrDie</span>(env, <span class="string">&quot;java/lang/Class&quot;</span>);</span><br><span class="line">    gClassOffsets.mGetName = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;getName&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(</span><br><span class="line">        env, kBinderProxyPathName,</span><br><span class="line">        gBinderProxyMethods, <span class="built_in">NELEM</span>(gBinderProxyMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-Binder中系统服务的注册过程"><a href="#Java-Binder中系统服务的注册过程" class="headerlink" title="Java Binder中系统服务的注册过程"></a><p class="m_more_title_style">Java Binder中系统服务的注册过程</p></h2><p>在系统服务的注册过程中，介绍的是Native Binder中的系统服务的注册过程，这一过程的核心是ServiceManager，而在Java Binder中，也有一个ServiceManager，只不过这个ServiceManager是Java文件。<br>既然要将系统服务注册到ServiceManager，那么需要选择一个系统服务为例，这里以常见的AMS为例。</p>
<h3 id="将AMS注册到ServiceManager"><a href="#将AMS注册到ServiceManager" class="headerlink" title="将AMS注册到ServiceManager"></a><strong>将AMS注册到ServiceManager</strong></h3><p>在AMS的setSystemProcess方法中，会调用ServiceManager的addService方法，如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java">ActivityManagerService.java</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Context.ACTIVITY_SERVICE 的值为”activity”，作用就是将AMS注册到ServiceManager中。</span></span><br><span class="line">        ServiceManager.<span class="built_in">addService</span>(Context.ACTIVITY_SERVICE, <span class="keyword">this</span>, <span class="comment">/* allowIsolated= */</span> <span class="literal">true</span>,</span><br><span class="line">                DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);</span><br><span class="line">       ....</span><br><span class="line">    &#125; <span class="built_in">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Unable to find android system package&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看ServiceManager的addService方法。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/ServiceManager.java">ServiceManager.java</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, boolean allowIsolated,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> dumpPriority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">getIServiceManager</span>().<span class="built_in">addService</span>(name, service, allowIsolated, dumpPriority);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.<span class="built_in">e</span>(TAG, <span class="string">&quot;error in addService&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要分析getIServiceManager方法返回的是什么，代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (sServiceManager != null) &#123;</span><br><span class="line">         <span class="keyword">return</span> sServiceManager;</span><br><span class="line">     &#125;</span><br><span class="line">     sServiceManager = ServiceManagerNative</span><br><span class="line">             .<span class="built_in">asInterface</span>(Binder.<span class="built_in">allowBlocking</span>(BinderInternal.<span class="built_in">getContextObject</span>()));</span><br><span class="line">     <span class="keyword">return</span> sServiceManager;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>讲到这里，已经积累了几个点需要分析，分别是：</p>
<ul>
<li>BinderInternal.getContextObject()</li>
<li>ServiceManagerNative.asInterface()</li>
<li>getIServiceManager().addService()</li>
</ul>
<h3 id="BinderInternal-getContextObject"><a href="#BinderInternal-getContextObject" class="headerlink" title="BinderInternal.getContextObject()"></a><strong>BinderInternal.getContextObject()</strong></h3><p>Binder.allowBlocking的作用是将BinderProxy的sWarnOnBlocking值置为false。主要来分析BinderInternal.getContextObject()做了什么，这个方法是一个Native方法，找到它对应的函数：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/android_util_Binder.cpp">android_util_Binder.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod gBinderInternalMethods[] = &#123;</span><br><span class="line">    &#123; <span class="string">&quot;getContextObject&quot;</span>, <span class="string">&quot;()Landroid/os/IBinder;&quot;</span>, (<span class="type">void</span>*)android_os_BinderInternal_getContextObject &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的函数为android_os_BinderInternal_getContextObject：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 最终返回的是BpBinder</span></span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">javaObjectForIBinder</span>(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessState::self()的作用是创建ProcessState。</p>
<p>BpBinder是Native Binder中的Client端，这说明Java层的ServiceManager需要Native层的BpBinder，但是这个BpBinder在Java层是无法直接使用，那么就需要传入javaObjectForIBinder函数来做处理，其内部会创建一个BinderProxy对象（BinderProxy是Java Binder的客户端的代表），这样我们得知 BinderInternal.getContextObject()最终得到的是BinderProxy。<br>需要注意的一点是，这个传入的BpBinder会保存到BinderProxy的成员变量mObject中。</p>
<h3 id="ServiceManagerNative-asInterface"><a href="#ServiceManagerNative-asInterface" class="headerlink" title="ServiceManagerNative.asInterface()"></a><strong>ServiceManagerNative.asInterface()</strong></h3><p>说到asInterface方法，在Native Binder中也有一个asInterface函数，IServiceManager的asInterface函数，它的作用是用BpBinder做为参数创建BpServiceManager。那么在Java Binder中的asInterface方法的作用又是什么？<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/ServiceManagerNative.java">ServiceManagerNative.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asInterface方法的作用就是用BinderProxy作为参数创建ServiceManagerProxy。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> IServiceManager <span class="title function_">asInterface</span><span class="params">(IBinder obj)</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">// obj的值为BinderProxy</span></span><br><span class="line">     <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">IServiceManager</span> <span class="variable">in</span> <span class="operator">=</span></span><br><span class="line">         (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">     <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> in;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceManagerProxy</span>(obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>BinderProxy和BpBinder分别在Jave Binder和Native Binder作为客户端的代表，BpServiceManager通过BpBinder来实现通信，同样的，ServiceManagerProxy也会将业务的请求交给BinderProxy来处理。<br>分析到这里，那么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sServiceManager = ServiceManagerNative</span><br><span class="line">        .<span class="built_in">asInterface</span>(Binder.<span class="built_in">allowBlocking</span>(BinderInternal.<span class="built_in">getContextObject</span>()));</span><br></pre></td></tr></table></figure>

<p>可以理解为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    sServiceManager = <span class="keyword">new</span> ServiceManagerProxy（BinderProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getIServiceManager-addService"><a href="#getIServiceManager-addService" class="headerlink" title="getIServiceManager().addService()"></a><strong>getIServiceManager().addService()</strong></h3><p>getIServiceManager()返回的是ServiceManagerProxy，ServiceManagerProxy是ServiceManagerNative的内部类，它实现了IServiceManager接口。来查看ServiceManagerProxy的addService方法。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/ServiceManagerNative.java">ServiceManagerNative.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* ServiceManagerProxy 类的 addService 方法</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(String name, IBinder service, <span class="type">boolean</span> allowIsolated, <span class="type">int</span> dumpPriority)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">  <span class="comment">// Parcel，它是一个数据包装器，将请求数据写入到Parcel类型的对象data中。</span></span><br><span class="line">    <span class="type">Parcel</span> <span class="variable">data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">    <span class="type">Parcel</span> <span class="variable">reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">    data.writeString(name);</span><br><span class="line">  <span class="comment">// 这里很关键</span></span><br><span class="line">    data.writeStrongBinder(service);</span><br><span class="line">    data.writeInt(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(dumpPriority);</span><br><span class="line">  <span class="comment">// 通过mRemote.transact将 Parcel 发送出去，mRemote实际上是BinderProxy。</span></span><br><span class="line">    mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BinderProxy.transact是native函数，实现的函数如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/android_util_Binder.cpp">android_util_Binder.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowNullPointerException</span>(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 将Java层的Parcel对象转化成为Native层的Parcel对象。</span></span><br><span class="line">    Parcel* data = <span class="built_in">parcelForJavaObject</span>(env, dataObj);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 将Java层的Parcel对象转化成为Native层的Parcel对象。</span></span><br><span class="line">    Parcel* reply = <span class="built_in">parcelForJavaObject</span>(env, replyObj);</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">NULL</span> &amp;&amp; replyObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 已知BpBinder会保存到BinderProxy的成员变量mObject中，因此在这里会从BinderProxy的成员变量mObject中获取BpBinder。</span></span><br><span class="line">    IBinder* target = <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowException</span>(env, <span class="string">&quot;java/lang/IllegalStateException&quot;</span>, <span class="string">&quot;Binder has been finalized!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line"><span class="comment">// 调用BpBinder的transact函数，向Binder驱动发送数据，可以看出Java Binder是需要Native Binder支持的，最终的目的就是向Binder驱动发送和接收数据。    </span></span><br><span class="line">    <span class="type">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引出JavaBBinder"><a href="#引出JavaBBinder" class="headerlink" title="引出JavaBBinder"></a><strong>引出JavaBBinder</strong></h3><p>接着回过头来分析data.writeStrongBinder(service)，代码如下所示。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/Parcel.java">Parcel.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeStrongBinder</span><span class="params">(IBinder ll)</span> &#123;</span><br><span class="line">      nativeWriteStrongBinder(mNativePtr, val);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>nativeWriteStrongBinder是Native方法，实现的函数为android_os_Parcel_writeStrongBinder：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/android_os_Parcel.cpp">android_os_Parcel.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_Parcel_writeStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="built_in">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">status_t</span> err = parcel-&gt;<span class="built_in">writeStrongBinder</span>(<span class="built_in">ibinderForJavaObject</span>(env, object));</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">signalExceptionForError</span>(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着查看 ibinderForJavaObject 函数：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/android_util_Binder.cpp">android_util_Binder.cpp</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ibinderForJavaObject</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 如果obj是Java层的Binder类，那么先获取JavaBBinderHolder对象，然后调用JavaBBinderHolder的get函数.</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh = (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;<span class="built_in">GetLongField</span>(obj, gBinderOffsets.mObject);</span><br><span class="line">        <span class="keyword">return</span> jbh-&gt;<span class="built_in">get</span>(env, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果obj是Java层的BinderProxy类，则返回BpBinder。</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;ibinderForJavaObject: %p is not a Binder object&quot;</span>, obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JavaBBinderHolder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">sp&lt;JavaBBinder&gt; <span class="title">get</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">      <span class="comment">// 成员变量mBinder是`wp&lt;JavaBBinder&gt;`类型的弱引用</span></span><br><span class="line">      <span class="comment">// 得到`sp&lt;JavaBBinder&gt;`类型的强引用b</span></span><br><span class="line">        sp&lt;JavaBBinder&gt; b = mBinder.<span class="built_in">promote</span>();</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// obj是一个Java层Binder对象</span></span><br><span class="line">          <span class="comment">// 创建JavaBBinder并赋值给b</span></span><br><span class="line">            b = <span class="keyword">new</span> <span class="built_in">JavaBBinder</span>(env, obj);</span><br><span class="line">            mBinder = b;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating JavaBinder %p (refs %p) for Object %p, weakCount=%&quot;</span> PRId32 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                 b.<span class="built_in">get</span>(), b-&gt;<span class="built_in">getWeakRefs</span>(), obj, b-&gt;<span class="built_in">getWeakRefs</span>()-&gt;<span class="built_in">getWeakCount</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// JavaBBinderHolder的get函数返回的是JavaBBinder。</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">sp&lt;JavaBBinder&gt; <span class="title">getExisting</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        <span class="keyword">return</span> mBinder.<span class="built_in">promote</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex           mLock;</span><br><span class="line">    wp&lt;JavaBBinder&gt; mBinder;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>data.writeStrongBinder(service)在本文中等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.<span class="built_in">writeStrongBinder</span>(<span class="keyword">new</span> <span class="built_in">JavaBBinder</span>(env，Binder))。</span><br></pre></td></tr></table></figure>

<p>讲到这里可以得知ServiceManager.addService()传入的并不是AMS本身，而是JavaBBinder。</p>
<h3 id="解析JavaBBinder"><a href="#解析JavaBBinder" class="headerlink" title="解析JavaBBinder"></a><strong>解析JavaBBinder</strong></h3><p>接着来分析JavaBBinder，查看它的构造函数：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/jni/android_util_Binder.cpp">android_util_Binder.cpp::JavaBBinderHolder::JavaBBinder</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JavaBBinder</span> : <span class="keyword">public</span> BBinder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">JavaBBinder</span>(JNIEnv* env, jobject <span class="comment">/* Java Binder */</span> c)</span><br><span class="line">        : <span class="built_in">mVM</span>(<span class="built_in">jnienv_to_javavm</span>(env)), <span class="built_in">mObject</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(object))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating JavaBBinder %p\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        gNumLocalRefsCreated.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">        <span class="built_in">gcIfManyNewRefs</span>(env);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以发现JavaBBinder继承了BBinder，那么JavaBBinder的作用是什么呢？当Binder驱动得到客户端的请求，紧接着会将响应发送给JavaBBinder，这时会调用JavaBBinder的onTransact函数，代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;                            </span><br><span class="line">       JNIEnv* env = <span class="built_in">javavm_to_jnienv</span>(mVM);</span><br><span class="line">       <span class="built_in">ALOGV</span>(<span class="string">&quot;onTransact() on %p calling object %p in env %p vm %p\n&quot;</span>, <span class="keyword">this</span>, mObject, env, mVM);</span><br><span class="line">       IPCThreadState* thread_state = IPCThreadState::<span class="built_in">self</span>();</span><br><span class="line">       <span class="type">const</span> <span class="type">int32_t</span> strict_policy_before = thread_state-&gt;<span class="built_in">getStrictModePolicy</span>();</span><br><span class="line">  <span class="comment">// 调用了Java层Binder的execTransact函数</span></span><br><span class="line">       jboolean res = env-&gt;<span class="built_in">CallBooleanMethod</span>(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">           code, <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">return</span> res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>查看 execTransact 函数。<a target="_blank" rel="noopener external nofollow noreferrer" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/android/os/Binder.java">Binder.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">execTransact</span><span class="params">(<span class="type">int</span> code, <span class="type">long</span> dataObj, <span class="type">long</span> replyObj,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (tracingEnabled) &#123;</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ALWAYS, getClass().getName() + <span class="string">&quot;:&quot;</span> + code);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// AMS实现了onTransact函数，从而完成业务实现。从这里可有看出，JavaBBinder并没有实现什么业务，当它接收到请求时，会调用Binder类的execTransact函数，execTransact函数内部又调用了onTransact函数，系统服务会重写onTransact函数来实现自身的业务功能。</span></span><br><span class="line">            res = onTransact(code, data, reply, flags);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException|RuntimeException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-Binder架构"><a href="#Java-Binder架构" class="headerlink" title="Java Binder架构"></a><strong>Java Binder架构</strong></h3><img data-src="https://imgsw.cn/static/images/Qud4yt.png?imageView2/2/h/600">

<p>Native Binder的部分在此前的文章已经讲过，这里主要来说说Java Binder部分，从图中可以看到：<br>1.Binder是服务端的代表，JavaBBinder继承BBinder，JavaBBinder通过mObject变量指向Binder。<br>2.BinderProxy是客户端的代表，ServiceManager的addService等方法会交由ServiceManagerProxy处理。<br>3.ServiceManagerProxy的成员变量mRemote指向BinderProxy对象，所以ServiceManagerProxy的addService等方法会交由BinderProxy来处理。<br>4.BinderProxy的成员变量mObject指向BpBinder对象，因此BinderProxy可以通过BpBinder和Binder驱动发送数据。</p>
<hr>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a><p class="m_more_title_style">备注</p></h2><p>注：源码基于 Android 9.0 版本</p>
<p><strong>参考资料：</strong><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/singwhatiwanna">Android 开发艺术探索</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://liuwangshu.cn/tags/Binder%E5%8E%9F%E7%90%86/">http://liuwangshu.cn/tags/Binder%E5%8E%9F%E7%90%86/</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://gityuan.com/tags/#binder">http://gityuan.com/tags/#binder</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://xiaozhuanlan.com/topic/9405168327">https://xiaozhuanlan.com/topic/9405168327</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/adaa1a39a274">https://www.jianshu.com/p/adaa1a39a274</a></p>

    </div>

    
    
    

    <footer class="post-footer">
<div class="post-block">
	
    <div style="text-align:center;color:#696969;font-size:14px;">------------- 本 文 结 束 ❤️ 感 谢 阅 读 -------------</div>
    
</div>



          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="非也缘也 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpeg" alt="非也缘也 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>非也缘也
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://jianghouren.cn/archives/8b4d12b5.html" title="Android Binder原理（一）">https://jianghouren.cn/archives/8b4d12b5.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/" rel="tag"># 通信机制</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/archives/3eb267f6.html" rel="prev" title="行为型设计模式">
                  <i class="fa fa-chevron-left"></i> 行为型设计模式
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/archives/fa8b41fe.html" rel="next" title="Android 直播技术基础知识">
                  Android 直播技术基础知识 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">非也缘也</span>
</div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div>
<span class="post-meta-item">

  	<span class="post-meta-item-icon">
	      <i class="fa fa-user"></i>
  	</span>
   <span>总访客&nbsp<span id="busuanzi_value_site_uv"></span>&nbsp人</span>
</span>

<span class="post-meta-item">
  	<span class="post-meta-item-icon">
	      <i class="fa fa-eye"></i>
  	</span>
   <span>总访问&nbsp<span id="busuanzi_value_site_pv"></span>&nbsp次</span>
</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>


  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://waline-git-main-feiyeyuanyes-projects.vercel.app/","placeholder":"请文明评论呀（填写邮箱可在被回复时收到邮件提醒）","avatar":"mm","pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/archives/8b4d12b5.html"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>

  <script async src="https://imgsw.cn/js/cursorfireworks.js"></script>





<div class="read_cut diyclass" id="read_cut"></div>
<div class="skin_peeler diyclass" id="skin_peeler"></div>
<div class="read_aloud diyclass" id="read_aloud"></div>
<div class="audioImg diyclass" id="audioImg"></div>
<audio id="audioMp3" controls="true" loop="loop"></audio>
<script src="/js/my-diy.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":66,"vOffset":-60},"mobile":{"show":false,"scale":0.5},"react":{"opacity":0.5},"log":false});</script></body>
</html>
